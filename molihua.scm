;;; Private parameters (for debugging/experiments etc.)
(define fix-offset #f)                  ; offset size or #f
(define sharp-edges '())                ; list of indices of the form ((face . loop) . edge)
(define sharp-offset 0.01)              ; offset distance for "sharp" edges
(define shrink-inwards-scaling 1)       ; extra scaling of inwards shrink
(define cross-tangent-scaling? #f)      ; does tangent scaling affect ribbon width?
(define new-tangent-setting? #f)        ; use the new tangent concept
(define tangent-scaling-everywhere? #f) ; when #f tangent scaling is applied only on triangles
(define magic-constant 4/5)             ; scaling of triangle end-cross-derivatives


;;; Global variables
(define vertices #f)                    ; vector of all vertices in the model
(define faces #f)                       ; vector of all faces (face ~ list of outer + inner loops);
                                        ;   a loop is a list of indices to `vertices`
(define offset-vertices #f)             ; vector of all offset vertices
(define offset-faces #f)                ; vector of all offset faces, similarly to `faces`,
                                        ;   but with indices to `offset-vertices`
(define offset-data #f)                 ; vector containing (normal ((lines . offset-lines) ...))
                                        ;   for each face of the model
(define offset-data-original #f)        ; same, retaining the original values (no shrink etc.)
(define vertex-faces #f)                ; vector containing adjacent face indices for vertex i;
                                        ;   an index is a cons cell (face-index . loop-index)
(define chamfer-max-scaling #f)         ; maximum scaling factor for each chamfer polygon
(define ribbons #f)                     ; vector of ribbons corresponding to the faces;
                                        ;   ((loop1-edge1 loop1-edge2 ...) (loop2-edge1 ...) ...)
                                        ;   note: edge1 is between the first two vertices etc.
(define misc-lines #f)                  ; list of line segments to draw (for experimenting)


;;; R7RS compatibility
(cond-expand
  (guile
   (use-modules (ice-9 rdelim))         ; read-line
   (define (vector-map f v)
     (let ((len (vector-length v)))
       (do ((result (make-vector len))
            (i 0 (+ i 1)))
           ((= i len) result)
         (vector-set! result i (f (vector-ref v i))))))
   (define (vector-for-each f v)
     (let ((len (vector-length v)))
       (do ((i 0 (+ i 1)))
           ((= i len))
         (f (vector-ref v i))))))
  (gambit))


;;; General utilities

(define-syntax bind-list
  (syntax-rules ()
    ((_ vars lst body ...)
     (apply (lambda vars body ...) lst))))

;;; `x` is assumed to be in `lst`;
;;; this gives the next element (first if `x` is last)
(define (next-element lst x)
  (let loop ((rest lst))
    (cond ((null? (cdr rest)) (car lst))
          ((eq? (car rest) x) (cadr rest))
          (else (loop (cdr rest))))))

(define (prev-element lst x)
  (next-element (reverse lst) x))

(define (reverse-pairs lst)
  (cond ((null? lst)
         '())
        ((pair? (car lst))
         (cons (cons (cdar lst) (caar lst))
               (reverse-pairs (cdr lst))))
        (else
         (cons (car lst)
               (reverse-pairs (cdr lst))))))

(define (flatten-pairs lst)
  (cond ((null? lst)
         '())
        ((pair? (car lst))
         (cons (caar lst)
               (cons (cdar lst)
                     (flatten-pairs (cdr lst)))))
        (else
         (cons (car lst)
               (flatten-pairs (cdr lst))))))

;;; Brings the last element to the beginning
(define (rotate lst)
  (let loop ((lst lst) (acc '()))
    (if (null? (cdr lst))
        (append lst (reverse acc))
        (loop (cdr lst) (cons (car lst) acc)))))

;;; Split by spaces; multiple spaces count as one.
;;; Newlines are also count as spaces; starting/ending spaces are discounted.
;;; Trim chunks starting with '/' characters.
(define (split-string s)
  (define (stringify-car! lst)
    (set-car! lst (list->string (reverse (car lst)))))
  (do ((result (list (list)))
       (skip #f)
       (lst (string->list s) (cdr lst)))
      ((null? lst)
       (if (null? (car result))
           (set! result (cdr result))
           (stringify-car! result))
       (reverse result))
    (case (car lst)
      ((#\space #\return #\newline)
       (unless (null? (car result))
         (stringify-car! result)
         (set! result (cons (list) result))
         (set! skip #f)))
      ((#\/)
       (set! skip #t))
      (else (unless skip
              (set-car! result
                        (cons (car lst) (car result))))))))

;;; List of integers (from .. end-1)
(define (range from end)
  (let loop ((from from))
    (if (= from end)
        '()
        (cons from (loop (+ from 1))))))

(define (find-index elt lst)
  (let loop ((i 0) (lst lst))
    (cond ((null? lst) #f)
          ((eq? (car lst) elt) i)
          (else (loop (+ i 1) (cdr lst))))))

(define (find-index-containing elt vec-of-lst)
  (call/cc
   (lambda (return)
     (do ((i 0 (+ i 1)))
         ((= i (vector-length vec-of-lst)) #f)
       (when (member elt (vector-ref vec-of-lst i))
         (return i))))))

(define (common-element a b)
  (let loop ((a a))
    (cond ((null? a) #f)
          ((member (car a) b) (car a))
          (else (loop (cdr a))))))

(define (common-elements a b)
  (let loop ((a a))
    (cond ((null? a) '())
          ((member (car a) b)
           (cons (car a) (loop (cdr a))))
          (else (loop (cdr a))))))

(define (disjoint? a b)
  (eq? (common-element a b) #f))

;;; Finds a list in lst (a list of lists) that has
;;; common elements with both a and b (both lists).
(define (find-connection a b lst)
  (let loop ((lst lst))
    (cond ((null? lst) #f)
          ((or (disjoint? (car lst) a)
               (disjoint? (car lst) b))
           (loop (cdr lst)))
          (else (car lst)))))

(define (nested-ref vec index)
  (list-ref (vector-ref vec (car index))
            (cdr index)))


;;; I/O routines

(define (read-obj filename)
  (with-input-from-file filename
    (lambda ()
      (do ((v '())
           (f '())
           (holes 0)
           (line (read-line) (read-line)))
          ((eof-object? line)
           (list (list->vector (reverse v))
                 (list->vector (reverse f))))
        (let ((type (or (and (< (string-length line) 2) "")
                        (substring line 0 2))))
          (cond ((string-ci=? type "#h")
                 (set! holes (string->number (cadr (split-string line)))))
                ((string-ci=? type "v ")
                    (let ((vertex (map string->number (cdr (split-string line)))))
                      (set! v (cons vertex v))))
                ((string-ci=? type "f ")
                 (let ((face (map (lambda (s)
                                    (- (string->number s) 1))
                                  (cdr (split-string line)))))
                   (cond ((> holes 0)
                          (set! holes (- holes 1))
                          (set-car! f (append (car f) (list face))))
                         (else
                          (set! f (cons (list face) f))))))))))))

(define (write-vertex v)
  (display "v")
  (for-each (lambda (xyz)
              (display " ")
              (display xyz))
            v)
  (newline))

(define (write-offsets filename)
  (define (write-loop loop)
    (display "f")
    (for-each (lambda (v)
                (cond ((pair? v)
                       (display " ")
                       (display (+ (car v) 1))
                       (display " ")
                       (display (+ (cdr v) 1)))
                      (else
                       (display " ")
                       (display (+ v 1)))))
              loop)
    (newline))
  (define (write-face face)
    (map write-loop face))
  (with-output-to-file filename
    (lambda ()
      (vector-for-each write-vertex offset-vertices)
      (if only-one-patch
          (write-face (vector-ref offset-faces only-one-patch))
          (vector-for-each write-face offset-faces)))))

(define (write-chamfers filename)
  (define (write-chamfer i)
    (display "f")
    (for-each (lambda (v)
                (cond ((pair? v)
                       (display " ")
                       (display (+ (cdr v) 1))
                       (display " ")
                       (display (+ (car v) 1)))
                      (else
                       (display " ")
                       (display (+ v 1)))))
              (chamfer i))
    (newline))
  (with-output-to-file filename
    (lambda ()
      (vector-for-each write-vertex offset-vertices)
      (if only-one-patch
          (for-each (lambda (loop)
                      (for-each write-chamfer loop))
                    (vector-ref faces only-one-patch))
          (do ((i 0 (+ i 1)))
              ((= i (vector-length vertices)))
            (write-chamfer i))))))

(define (write-polyhedron filename)
  (define (get-chamfer-point f i j)
    (let ((p (list-ref (nested-ref offset-faces i) j)))
      (if (pair? p) (f p) p)))
  (define (write-loop loop)
    (cond ((number? loop)
           (display "#h ")
           (display loop))
          (else
           (display "f")
           (for-each (lambda (v)
                       (cond ((pair? v)
                              (display " ")
                              (display (+ (car v) 1))
                              (display " ")
                              (display (+ (cdr v) 1)))
                             (else
                              (display " ")
                              (display (+ v 1)))))
                     loop)))
    (newline))
  (let ((loops '()))
    (do ((i 0 (+ i 1)))
        ((= i (vector-length vertices)))
      (set! loops (cons (reverse-pairs (chamfer i)) loops)))
    (vector-for-each (lambda (face)
                       (set! loops (append face loops))
                       (when (> (length face) 1)
                         (set-cdr! loops (cons (- (length face) 1) (cdr loops)))))
                     offset-faces)
    (do ((i 0 (+ i 1)))
        ((= i (vector-length faces)))
      (let ((face (vector-ref faces i)))
        (do ((j 0 (+ j 1)))
            ((= j (length face)))
          (let ((loop (list-ref face j)))
            (do ((k 0 (+ k 1)))
                ((= k (length loop)))
              (let* ((index (cons (cons i j) k))
                     (opp (opposite-side (cons i j) k))
                     (opp-loop (nested-ref faces (car opp)))
                     (k1 (modulo (+ k 1) (length loop)))
                     (k2 (modulo (+ (cdr opp) 1) (length opp-loop)))
                     (p0 (get-chamfer-point cdr (car index) (cdr index)))
                     (p1 (get-chamfer-point car (car index) k1))
                     (p2 (get-chamfer-point cdr (car opp) (cdr opp)))
                     (p3 (get-chamfer-point car (car opp) k2)))
                (when (< (caar index) (caar opp))
                  (set! loops (cons (list p3 p2 p1 p0) loops)))))))))
    (with-output-to-file filename
      (lambda ()
        (vector-for-each write-vertex offset-vertices)
        (for-each write-loop loops)))))

;;; Show ribbon in Obj format;
;;; index is the number of already printed vertices.
;;; Returns the new index.
(define (show-ribbon ribbon index)
  (for-each write-vertex (append (car ribbon) (cdr ribbon)))
  (let ((line (lambda (indices)
                (display "l")
                (for-each (lambda (v)
                            (display " ")
                            (display (+ index v)))
                          indices)
                (newline))))
    (line '(1 2 3 4))
    (line '(5 6 7 8))
    (line '(1 5))
    (line '(2 6))
    (line '(3 7))
    (line '(4 8)))
  (+ index 8))

(define (write-controls filename)
  (with-output-to-file filename
    (lambda ()
      (do ((index 0)
           (i 0 (+ i 1)))
          ((= i (vector-length faces)))
        (when (or (not only-one-patch)
                  (= only-one-patch i))
          (for-each (lambda (loop)
                      (for-each (lambda (ribbon)
                                  (set! index (show-ribbon ribbon index)))
                                loop)) 
                    (vector-ref ribbons i)))))))

(define (knot-string degree with-size?)
  (parameterize ((current-output-port (open-output-string)))
    (when with-size?
      (display (* (+ degree 1) 2))
      (display " "))
    (do ((i 0 (+ i 1)))
        ((> i degree))
      (display "0 "))
    (do ((i 0 (+ i 1)))
        ((= i degree) (display 1))
      (display "1 "))
    (get-output-string (current-output-port))))

(define (write-patch-mgbs patch filename)
  (with-output-to-file filename
    (lambda ()
      (let ((k (length patch)))
        (display k) (newline)                                               ; # of loops
        (for-each (lambda (loop)
                    (display (length loop)) (newline)                       ; # of sides
                    (for-each (lambda (ribbon)
                                (let ((deg (- (length (car ribbon)) 1)))
                                  (display deg) (display " ")               ; s-deg
                                  (display deg) (display " ")               ; h-deg
                                  (display "2 0") (newline)                 ; layers ribcp?
                                  (display (knot-string deg #f)) (newline)) ; s-knots
                                (for-each (lambda (p)
                                            (display (car p)) (display " ")
                                            (display (cadr p)) (display " ")
                                            (display (caddr p)) (newline))
                                          (append (car ribbon) (cdr ribbon))))
                              loop))
                  patch)

        (display "400 200") (newline)))))

(define (write-patches-mgbs filename-prefix)
  (do ((index 0)
       (i 0 (+ i 1)))
      ((= i (vector-length ribbons)))
    (when (or (not only-one-patch)
              (= only-one-patch i))
      (write-patch-mgbs (vector-ref ribbons i)
                        (string-append filename-prefix (number->string (+ i 1)) ".mgbs")))))


;;; Geometry procedures

(define (v+ . args)
  (apply map + args))

(define (v- . args)
  (apply map - args))

(define (v* u . args)
  (map (lambda (x) (apply * x args)) u))

(define (scalar-product u v)
  (apply + (map * u v)))

(define (cross-product u v)
  (list (- (* (cadr u) (caddr v)) (* (caddr u) (cadr v)))
	(- (* (caddr u) (car v)) (* (car u) (caddr v)))
	(- (* (car u) (cadr v)) (* (cadr u) (car v)))))

(define (vlength u)
  (sqrt (scalar-product u u)))

(define (vnormalize u)
  (v* u (/ (vlength u))))

;;; Returns (a . b) such that u = v a + w b.
(define (in-system u v w)
  (let ((v2 (scalar-product v v))
        (w2 (scalar-product w w))
        (uv (scalar-product u v))
        (uw (scalar-product u w))
        (vw (scalar-product v w)))
    (let ((denom (- (* v2 w2) (* vw vw))))
      (cons (/ (- (* w2 uv) (* vw uw)) denom)
            (/ (- (* v2 uw) (* vw uv)) denom)))))

(define (point-distance p q)
  (vlength (v- q p)))

;;; Line is given as (point . point)
(define (line-point-distance line p)
  (let* ((q1 (car line))
         (q2 (cdr line))
         (v (v- p q1))
         (d (v- q2 q1)))
    (vlength (v- v (v* d (/ (scalar-product v d)
                            (scalar-product d d)))))))

;;; Pushes the line towards the point by `offset` part of their distance
(define (push-line line point offset)
  (let ((d (v* (v- point (car line)) offset)))
    (cons (v+ (car line) d)
          (v+ (cdr line) d))))

(define (line-line-intersection l1 l2)
  (let* ((ap (car l1))
         (ad (v- (cdr l1) (car l1)))
         (bp (car l2))
         (bd (v- (cdr l2) (car l2)))
         (a (scalar-product ad ad))
         (b (scalar-product ad bd))
         (c (scalar-product bd bd))
         (d (scalar-product ad (v- ap bp)))
         (e (scalar-product bd (v- ap bp))))
    (let ((denom (- (* a c) (* b b))))
      (if (< denom 1e-5)
          #f
          (let ((s (/ (- (* b e) (* c d)) denom))
                (t (/ (- (* a e) (* b d)) denom)))
            (v* (v+ ap (v* ad s) bp (v* bd t)) 0.5))))))

;;; Closest point of `l1` to `l2`
(define (line-line-closest-point l1 l2)
  (let* ((ap (car l1))
         (ad (v- (cdr l1) (car l1)))
         (bp (car l2))
         (bd (v- (cdr l2) (car l2)))
         (a (scalar-product ad ad))
         (b (scalar-product ad bd))
         (c (scalar-product bd bd))
         (d (scalar-product ad (v- ap bp)))
         (e (scalar-product bd (v- ap bp))))
    (let ((denom (- (* a c) (* b b))))
      (if (< denom 1e-5)
          ap                            ; kutykurutty
          (let ((s (/ (- (* b e) (* c d)) denom)))
            (v+ ap (v* ad s)))))))

;;; As a special case it checks the endpoints and the defining points of the line explicitly.
;;; Always returns a point on the segment (or #f)
(define (line-segment-intersection l s)
  (cond ((or (equal? (car l) (car s))
             (equal? (cdr l) (car s)))
         (car s))
        ((or (equal? (car l) (cdr s))
             (equal? (cdr l) (cdr s)))
         (cdr s))
        (else
         (let* ((ap (car l))
                (ad (v- (cdr l) (car l)))
                (bp (car s))
                (bd (v- (cdr s) (car s)))
                (a (scalar-product ad ad))
                (b (scalar-product ad bd))
                (c (scalar-product bd bd))
                (d (scalar-product ad (v- ap bp)))
                (e (scalar-product bd (v- ap bp))))
           (let ((denom (- (* a c) (* b b))))
             (if (< denom 1e-10)
                 #f
                 (let ((t (/ (- (* a e) (* b d)) denom)))
                   (if (<= 0 t 1)
                       (v+ bp (v* bd t))
                       #f))))))))

(define (out-normal line1 line2)
  (let* ((d1 (v- (cdr line1) (car line1)))
         (d2 (v- (cdr line2) (car line2))))
    (cross-product d1 d2)))

(define (concave-corner? line1 line2 normal)
  (< (scalar-product normal (out-normal line1 line2)) 0))

;;; Is `p` on the same side of `line` as `q`?
;;; Handle the case when `p` is essentially on `line`
(define (same-side? line p q)
  (let ((c1 (cross-product (v- (car line) p)
                           (v- (cdr line) p)))
        (c2 (cross-product (v- (car line) q)
                           (v- (cdr line) q))))
    (or (< (vlength c1) 1e-3)
        (>= (scalar-product c1 c2) 0))))

(define (positive-side? line p normal)
  (>= (scalar-product
       (cross-product (v- (car line) p)
                      (v- (cdr line) p))
       normal)
      0))

;;; Is the vertex `v` in the wedge region defined by the two lines `a` and `b`?
;;; Note that the region is capped by the segment connecting `a` and `b`, i.e.,
;;; - v should be on the same side of `a` and `b` as the midpoint of `s`
;;; - v should be on the positive side of `s` (w.r.t. the normal `n`)
(define (in-wedge-region? v a b n)
  (let ((s (cons (cdr a) (car b))))
    (and (positive-side? s v n)
         (or (equal? v (car a))
             (equal? v (cdr b))
             (let ((m (v* (v+ (car s) (cdr s)) 0.5)))
               (and (same-side? a v m)
                    (same-side? b v m)))))))

;;; As an alternative to `offset-line`
(define (constant-offset-line segment normal offset)
  (push-line segment (v+ (car segment)
                         (vnormalize (cross-product normal
                                                    (v- (cdr segment) (car segment)))))
             offset))

;;; Find the offset of `segment` that is `ratio` of the maximum offset,
;;; where the maximum is at the first intersection point,
;;; considering intersections with other segments in `segments` excluding `prev` and `next`,
;;; and the point of intersection should be in the wedge area defined by `prev` and `next`.
;;; Returns a line expressed as the CONS of two points.
(define (offset-line segments segment prev next ratio normal)
  (let* ((v (line-line-intersection prev next))
         (ok (and v (in-wedge-region? v prev next normal))))
    (let loop ((lst segments)
               (d (if ok (line-point-distance segment v) +inf.0))
               (off (if ok (push-line segment v ratio) #f)))
      (if (null? lst)
          (or off (error "offset-line: cannot find offset"))
          (let ((s (car lst)))
            (if (or (equal? s segment) (equal? s prev) (equal? s next))
                (loop (cdr lst) d off)
                (let select ((candidates (list (car s) (cdr s)
                                               (line-segment-intersection prev s)
                                               (line-segment-intersection next s)))
                             (d* d) (off* off))
                  (if (null? candidates)
                      (loop (cdr lst) d* off*)
                      (let* ((v (car candidates))
                             (d? (if v (line-point-distance segment v) +inf.0)))
                        (if (and (< d? d*) (in-wedge-region? v prev next normal))
                            (select (cdr candidates) d? (push-line segment v ratio))
                            (select (cdr candidates) d* off*)))))))))))

;;; Returns (normal ((lines . offset-lines) ...))
;;; Assumes that the first corner is not concave
(define (offset-face loops)
  (let* ((all-lines (map (lambda (verts)
                           (map cons verts (append (cdr verts) (list (car verts)))))
                         loops))
         (segments (apply append all-lines))
         (normal (face-normal (car loops))))
    (cons normal
          (map (lambda (lines)
                 (cons lines
                       (if fix-offset
                           (map (lambda (l)
                                  (constant-offset-line l normal fix-offset))
                                lines)
                           (map (lambda (l p n)
                                  (offset-line segments l p n (/ fullness 2) normal))
                                lines (rotate lines) (append (cdr lines) (list (car lines)))))))
               all-lines))))

;;; Intersect the offset lines to create inner polygons
(define (create-offset-polygon offset-face-data)
  (let ((normal (car offset-face-data)))
    (map (lambda (pair)
           (let ((lines (car pair))
                 (offsets (cdr pair)))
             (let loop ((l1 (rotate lines)) (l2 lines)
                        (o1 (rotate offsets)) (o2 offsets))
               (cond ((null? l1)
                      '())
                     ((concave-corner? (car l1) (car l2) normal)
                      (cons (list 'concave
                                  (line-line-intersection (car o1) (car l2))
                                  (line-line-intersection (car o2) (car l1)))
                            (loop (cdr l1) (cdr l2) (cdr o1) (cdr o2))))
                     (else
                      (cons (or (line-line-intersection (car o1) (car o2))
                                (project-to-line (car o1) (cdar l1)))
                            (loop (cdr l1) (cdr l2) (cdr o1) (cdr o2))))))))
         (cdr offset-face-data))))

(define (generate-all-offset-lines)
  (define (get-points indices)
    (map (lambda (v)
           (vector-ref vertices v))
         indices))
  (let ((result (make-vector (vector-length faces))))
    (do ((i 0 (+ i 1)))
        ((= i (vector-length faces))
         result)
      (vector-set! result i
                   (offset-face (map get-points (vector-ref faces i)))))))

;;; The lines `base` and `line` are both given as (point1 . point2).
(define (push-line-to-distance base line d)
  (let ((old-d (line-point-distance base (car line))))
    (push-line base (car line) (/ d old-d))))

;;; Finds all edges and takes the closest of the two offset distances
;;; For edges in `sharp-edges` set the offset to `sharp-offset`
;;; Works directly on `offset-data`
(define (take-edge-min-offsets!)
  (define (line index)
    (list-ref (car (list-ref (cdr (vector-ref offset-data (caar index)))
                             (cdar index)))
              (cdr index)))
  (define (offset index)
    (list-ref (cdr (list-ref (cdr (vector-ref offset-data (caar index)))
                             (cdar index)))
              (cdr index)))
  (define (set-offset! index value)
    (set-car! (list-tail (cdr (list-ref (cdr (vector-ref offset-data (caar index)))
                                        (cdar index)))
                         (cdr index))
              value))
  (do ((i 0 (+ i 1)))
      ((= i (vector-length faces)))
    (let ((face (vector-ref faces i)))
      (do ((j 0 (+ j 1)))
          ((= j (length face)))
        (let ((loop (list-ref face j)))
          (do ((k 0 (+ k 1)))
              ((= k (length loop)))
            (let* ((edge (list-ref loop k))
                   (index1 (cons (cons i j) k))
                   (index2 (opposite-side (cons i j) k))
                   (l (line index1))
                   (l1 (offset index1))
                   (l2 (offset index2))
                   (d1 (line-point-distance l (car l1)))
                   (d2 (line-point-distance l (car l2)))
                   (d (/ (+ d1 d2) 2))
                   ;; (d (min d1 d2))
                   (d1* (min d (* d1 (/ 0.9 fullness)))))
              (if (or (member index2 sharp-edges)
                      (member index1 sharp-edges))
                  (set-offset! index1 (push-line-to-distance l l1 sharp-offset))
                  (set-offset! index1 (push-line-to-distance l l1 d1*))))))))))

;;; Returns (verts* . faces*)
(define (generate-offsets)
  (do ((rfaces (make-vector (vector-length faces)))
       (rvertices '())
       (index 0)
       (i 0 (+ i 1)))
      ((= i (vector-length faces))
       (cons (list->vector (reverse rvertices)) rfaces))
    (vector-set! rfaces i
                 (map (lambda (off)
                        (let* ((flat (apply append (map (lambda (x)
                                                          (if (eq? (car x) 'concave)
                                                              (cdr x)
                                                              (list x)))
                                                        off)))
                               (n (length flat)))
                          (set! rvertices (append (reverse flat) rvertices))
                          (set! index (+ index n))
                          (let loop ((lst off) (i (- index n)))
                            (cond ((null? lst)
                                   '())
                                  ((eq? (caar lst) 'concave)
                                   (cons (cons i (+ i 1))
                                         (loop (cdr lst) (+ i 2))))
                                  (else
                                   (cons i (loop (cdr lst) (+ i 1))))))))
                      (create-offset-polygon (vector-ref offset-data i))))))

(define (update-topology)
  (set! vertex-faces
    (do ((result (make-vector (vector-length vertices) '()))
         (i 0 (+ i 1)))
        ((= i (vector-length faces))
         (let loop ((j (- (vector-length result) 1)) (acc '()))
           (if (< j 0)
               (list->vector acc)
               (loop (- j 1)
                     (cons (fix-order-around j (vector-ref result j))
                           acc)))))
      (do ((j 0 (+ j 1))
           (lst (vector-ref faces i) (cdr lst)))
          ((null? lst))
        (for-each (lambda (v)
                    (vector-set! result v
                                 (cons (cons i j) (vector-ref result v))))
                  (car lst))))))

(define (clone-offset-data)
  (define (deep-copy lst)
    (cond
     ((null? lst) '())
     ((pair? lst)
      (cons (deep-copy (car lst))
            (deep-copy (cdr lst))))
     (else lst)))
  (let ((v (make-vector (vector-length offset-data))))
    (for-each (lambda (i)
                (vector-set! v i (deep-copy (vector-ref offset-data i))))
              (range 0 (vector-length offset-data)))
    v))

(define (update-offsets)
  (set! offset-data (generate-all-offset-lines))
  (set! offset-data-original (clone-offset-data))
  (when edge-based-offsets?
      (take-edge-min-offsets!))
  (let ((offsets (generate-offsets)))
    (set! offset-vertices (car offsets))
    (set! offset-faces (cdr offsets)))
  (when (or shrink-inwards? shrink-outwards?)
    (for-each shrink-chamfer! (range 0 (vector-length vertices))))
  (let ((offsets (generate-offsets)))
    (set! offset-vertices (car offsets))
    (set! offset-faces (cdr offsets))))

;;; Moves the adjacent face to the beginning
;;; Adjacency means that there is (u v) in one, and (v u) in the other
(define (select-adjacent v face lst)
  (define (face-with-vertex f)
    (let ((lst (nested-ref faces f)))
      (if (memq v lst)
          lst
          (let find ((hs holes))
            (let ((h (car hs)))
              (if (and (= (car h) f)
                       (memq v (cdr h)))
                  (cdr h)
                  (find (cdr hs))))))))
  (let loop ((lst lst) (acc '()))
    (cond ((null? lst)
           (error "cannot find adjacent face"))
          ((let ((a (face-with-vertex face))
                 (b (face-with-vertex (car lst))))
             (or (= (next-element a v) (prev-element b v))
                 (= (prev-element a v) (next-element b v))))
           (cons (car lst) (append acc (cdr lst))))
          (else
           (loop (cdr lst) (cons (car lst) acc))))))

;;; Permute the list of faces to be cyclic
(define (fix-order-around v faces)
  (let loop ((lst faces))
    (if (null? (cdr lst))
        lst
        (cons (car lst)
              (loop (select-adjacent v (car lst) (cdr lst)))))))

;;; Sum the cross products of each edge endpoints & normalize
(define (face-normal points)
  (let ((edges (map cons points (append (cdr points) (list (car points))))))
    (vnormalize
     (let loop ((lst edges))
       (if (null? lst)
           '(0 0 0)
           (v+ (cross-product (caar lst) (cdar lst))
               (loop (cdr lst))))))))

;;; Returns the chamfer associated with the v-th vertex.
;;; The result is a list of indices to offset-vertices.
(define (chamfer v)
  (let* ((face-indices (vector-ref vertex-faces v))
         (lst (map (lambda (f)
                     (list-ref (nested-ref offset-faces f)
                               (find-index v (nested-ref faces f))))
                   face-indices))
         (face (map (lambda (v) (vector-ref vertices v))
                    (nested-ref faces (car face-indices))))
         (chamfer-face (map (lambda (v)
                              (if (pair? v)
                                  (v* (v+ (vector-ref offset-vertices (car v))
                                          (vector-ref offset-vertices (cdr v)))
                                      1/2)
                                  (vector-ref offset-vertices v)))
                            lst)))
    (if (< (scalar-product (face-normal face)
                           (face-normal chamfer-face))
           0)
        (reverse lst)
        lst)))

;;; The line is given as (point1 . point2)
(define (project-to-line line p)
  (let ((t (vnormalize (v- (cdr line) (car line)))))
    (v+ (car line)
        (v* t (scalar-product t (v- p (car line)))))))

;;; The plane is given as (point . unit-normal)
(define (project-to-plane plane p)
  (v+ p (v* (cdr plane)
            (scalar-product (v- (car plane) p)
                            (cdr plane)))))

;;; Converts a (planar) polygon to a plane of the format (point . unit-normal)
(define (poly->plane points)
  (cons (car points)
        (vnormalize (cross-product (v- (car points) (cadr points))
                                   (v- (caddr points) (cadr points))))))

;;; `plane` is (point . unit-normal), `line` is (point1 . point2)
(define (plane-line-intersection plane line)
  (let* ((d (v- (cdr line) (car line)))
         (denom (scalar-product d (cdr plane))))
    (if (< (abs denom) 1e-8)
        #f
        (v+ (car line)
            (v* d (/ (scalar-product (v- (car plane) (car line))
                                     (cdr plane))
                     denom))))))

;;; Updates `offset-data` such that the offset vertex `v` is repositioned to `p`
;;; Does not let the distance become negative or larger than the original * 0.9 / fullness
(define (set-offset-line-by-vertex! v p)
  (define (set-offset i j k)
    (let* ((lo (list-ref (cdr (vector-ref offset-data i)) j))
           (line (list-ref (car lo) k))
           (offset (list-ref (cdr lo) k))
           (original (list-ref (cdr (list-ref (cdr (vector-ref offset-data-original i)) j)) k))
           (dmax (* (line-point-distance line (car original)) (/ 0.9 fullness)))
           (d (min (line-point-distance line p) dmax))
           (line-new (push-line-to-distance line original d)))
      (set-car! (list-tail (cdr lo) k) line-new)))
  (do ((i 0 (+ i 1)))
      ((= i (vector-length offset-faces)))
    (let ((face (vector-ref offset-faces i)))
      (do ((j 0 (+ j 1)))
          ((= j (length face)))
        (let ((loop (list-ref face j)))
          (do ((k 0 (+ k 1)))
              ((= k (length loop)))
            (let ((index (list-ref loop k)))
              (when (and (number? index) (= index v))
                (set-offset i j k)
                (set-offset i j (modulo (+ k (length loop) -1) (length loop)))))))))))

(define (shrink-chamfer! v)
  (let ((indices (chamfer v)))
    (when (and (= (length indices) 3)     ; cannot handle vertices of degree != 3 (kutykurutty)
               (let check ((lst indices)) ; check if no concave corner is present (kutykurutty)
                    (or (null? lst)
                        (and (not (pair? (car lst)))
                             (check (cdr lst))))))
      (let* ((corner (vector-ref vertices v))
             (points (map (lambda (i)
                            (vector-ref offset-vertices i))
                          indices))
             (face-indices (vector-ref vertex-faces v))
             (polys (map (lambda (i)
                           (let find ((lst face-indices))
                             (if (memq i (nested-ref offset-faces (car lst)))
                                 (map (lambda (j)
                                        (vector-ref vertices j))
                                      (nested-ref faces (car lst)))
                                 (find (cdr lst)))))
                         indices))
             (normals (map face-normal polys)))
        ;; 1. Project the j-k chamfer line to i's plane along the intersection of j & k planes
        ;; 2. If offset vertex i is on different side than the corner => OK
        ;; 3. Otherwise find the translation for the line to go through offset vertex i
        ;; 4. Translate offset vertices j and k by this vector
        ;; 5. Intersect the new j-k line by the j & k planes to get the new points
        (define (shrink-one! i j k)
          (let* ((pi (list-ref points i))
                 (pj (list-ref points j))
                 (pk (list-ref points k))
                 (plane (cons corner (list-ref normals i)))
                 (dir (cross-product (list-ref normals j) (list-ref normals k)))
                 (pj* (plane-line-intersection plane (cons pj (v+ pj dir))))
                 (pk* (plane-line-intersection plane (cons pk (v+ pk dir)))))
            (when (same-side? (cons pj* pk*) pi corner)
              (let* ((t (vnormalize (v- pk* pj*)))
                     (d (v- pi (v+ pk* (v* t (scalar-product t (v- pi pk*))))))
                     (line (cons (v+ pj d) (v+ pk d)))
                     (qj (plane-line-intersection (poly->plane (list-ref polys j)) line))
                     (qk (plane-line-intersection (poly->plane (list-ref polys k)) line)))
                (when shrink-inwards?
                  (let ((pi* (v+ pk* (v* t (scalar-product t (v- pi pk*))))))
                    (set-offset-line-by-vertex! (list-ref indices i)
                                                (v+ pi (v* (v- pi* pi) shrink-inwards-scaling)))))
                (when (and qj qk shrink-outwards?)
                  (set-offset-line-by-vertex! (list-ref indices j) qj)
                  (set-offset-line-by-vertex! (list-ref indices k) qk))))))
        (define (not-parallel? i j)
          (> (vlength (cross-product (list-ref normals i) (list-ref normals j))) 1e-5))
        (when (and (not-parallel? 0 1) (not-parallel? 1 2) (not-parallel? 2 0))
          (shrink-one! 0 1 2)
          (shrink-one! 1 2 0)
          (shrink-one! 2 0 1))))))

;;; At vertex j with chamfer c0, find the face connecting to chamfer c1,
;;; which is the opposite of face i (i.e., not face i).
(define (find-opposite i j c0 c1)
  (let ((candidates
         (let loop ((lst (vector-ref vertex-faces j)))
           (cond ((null? lst) '())
                 ((equal? (car lst) i) (loop (cdr lst)))
                 (else (cons (nested-ref offset-faces (car lst))
                             (loop (cdr lst))))))))
    (or (find-connection c0 c1 candidates)
        (error "no opposite face"))))

;;; Cuts back a line segment (p . q) to at most distance d (the starting point is unchanged)
(define (line-cutback line d)
  (let ((d0 (point-distance (car line) (cdr line))))
    (if (<= d0 d)
        line
        (cons (car line)
              (v+ (car line)
                  (v* (vnormalize (v- (cdr line) (car line))) d))))))

(define (chamfer-plane i)
  (let ((points (map (lambda (j) (vector-ref offset-vertices j))
                     (flatten-pairs (chamfer i)))))
    (cons (car points)
          (vnormalize (cross-product (v- (cadr points) (car points))
                                     (v- (caddr points) (car points)))))))

(define (chamfer-midpoint i)
  (let ((flat (flatten-pairs (chamfer i))))
    (v* (apply v+ (map (lambda (v)
                         (vector-ref offset-vertices v))
                       flat))
        (/ (length flat)))))

(define (update-chamfer-scalings)
  (define (update-scaling i s)
    (let ((old (vector-ref chamfer-max-scaling i)))
      (unless (and old (< old s))
        (vector-set! chamfer-max-scaling i s))))
  (define (select-offset f i)
    (let ((i (if (pair? i) (f i) i)))
      (vector-ref offset-vertices i)))
  (set! chamfer-max-scaling (make-vector (vector-length vertices) #f))
  (do ((i 0 (+ i 1)))
      ((= i (vector-length faces)))
    (let ((face (vector-ref faces i)))
      (do ((j 0 (+ j 1)))
          ((= j (length face)))
        (let* ((loop (list-ref face j))
               (n (length loop)))
          (do ((k 0 (+ k 1)))
              ((= k n))
            (let* ((k+1 (modulo (+ k 1) n))
                   (v0 (list-ref loop k))
                   (v1 (list-ref loop k+1))
                   (c0 (chamfer v0))
                   (c1 (chamfer v1))
                   (m0 (chamfer-midpoint v0))
                   (m1 (chamfer-midpoint v1))
                   (max-length (/ (point-distance m0 m1) 3))
                   (o0 (select-offset cdr (list-ref (nested-ref offset-faces (cons i j)) k)))
                   (o1 (select-offset car (list-ref (nested-ref offset-faces (cons i j)) k+1)))
                   (opp (find-opposite (cons i j) v0 c0 c1))
                   (e0 (v* (v+ o0 (select-offset car (common-element c0 opp))) 1/2))
                   (e1 (v* (v+ o1 (select-offset car (common-element c1 opp))) 1/2))
                   (r0 (/ max-length (point-distance e0 m0)))
                   (r1 (/ max-length (point-distance e1 m1))))
              (update-scaling v0 r0)
              (update-scaling v1 r1))))))))

(define (generate-ribbon i j)
  (if new-tangent-setting?
      (generate-ribbon-new i j)
      (generate-ribbon-old i j)))

;;; Face i side j
;;; m: chamfer midpoint
;;; o: chamfer vertex in the current face
;;; e: chamfer midpoint between the current and opposite faces
;;; f: chamfer midpoint between the current and adjacent-opposite faces
(define (generate-ribbon-old i j)
  (let* ((face (nested-ref faces i))
         (offset-face (nested-ref offset-faces i))
         (n (length face))
         (j-1 (modulo (- j 1) n))
         (j+1 (modulo (+ j 1) n))
         (j+2 (modulo (+ j 2) n))
         (c0 (chamfer (list-ref face j)))
         (c1 (chamfer (list-ref face j+1)))
         (fc0 (flatten-pairs c0))
         (fc1 (flatten-pairs c1))
         (m0 (v* (apply v+ (map (lambda (v)
                                  (vector-ref offset-vertices v))
                                fc0))
                 (/ (length fc0))))
         (m1 (v* (apply v+ (map (lambda (v)
                                  (vector-ref offset-vertices v))
                                fc1))
                 (/ (length fc1))))
         (select-from-pair (lambda (f x) (if (pair? x) (f x) x)))
         (scale0 (if (or tangent-scaling-everywhere? (= (length fc0) 3)) tangent-scale 1))
         (scale1 (if (or tangent-scaling-everywhere? (= (length fc1) 3)) tangent-scale 1))
         (scaled-offset (lambda (c f i s)
                          (let ((i (select-from-pair f i)))
                            (v+ c (v* (v- (vector-ref offset-vertices i) c) s)))))
         (o0 (scaled-offset m0 cdr (list-ref offset-face j) scale0))
         (o1 (scaled-offset m1 car (list-ref offset-face j+1) scale1))
         ;; the opposite face includes a vertex index from both c0 and c1
         (opp (find-opposite i (list-ref face j) c0 c1))
         (opp-1 (find-opposite i (list-ref face j) c0 (chamfer (list-ref face j-1))))
         (opp+1 (find-opposite i (list-ref face j+1) c1 (chamfer (list-ref face j+2))))
         (e0 (v* (v+ o0 (scaled-offset m0 car (common-element c0 opp) scale0)) 1/2))
         (e1 (v* (v+ o1 (scaled-offset m1 cdr (common-element c1 opp) scale1)) 1/2))
         (f0 (v* (v+ o0 (if (pair? (list-ref offset-face j))
                            (scaled-offset m0 car (list-ref offset-face j) scale0)
                            (scaled-offset m0 cdr (common-element c0 opp-1) scale1)))
                 1/2))
         (f1 (v* (v+ o1 (if (pair? (list-ref offset-face j+1))
                            (scaled-offset m1 cdr (list-ref offset-face j+1) scale0)
                            (scaled-offset m1 car (common-element c1 opp+1) scale1)))
                 1/2)))
    (cons (list m0 e0 e1 m1)
          (if cross-tangent-scaling?
              (list f0 o0 o1 f1)
              (list (v+ m0 (v* (v- f0 m0) (/ scale0)))
                    (v+ e0 (v* (v- o0 e0) (/ scale0)))
                    (v+ e1 (v* (v- o1 e1) (/ scale1)))
                    (v+ m1 (v* (v- f1 m1) (/ scale1))))))))

(define (generate-ribbon-new i j)
  (let* ((face (nested-ref faces i))
         (offset-face (nested-ref offset-faces i))
         (n (length face))
         (j-1 (modulo (- j 1) n))
         (j+1 (modulo (+ j 1) n))
         (j+2 (modulo (+ j 2) n))
         (c0 (chamfer (list-ref face j)))
         (c1 (chamfer (list-ref face j+1)))
         (fc0 (flatten-pairs c0))
         (fc1 (flatten-pairs c1))
         (m0 (v* (apply v+ (map (lambda (v)
                                  (vector-ref offset-vertices v))
                                fc0))
                 (/ (length fc0))))
         (m1 (v* (apply v+ (map (lambda (v)
                                  (vector-ref offset-vertices v))
                                fc1))
                 (/ (length fc1))))
         (select-from-pair (lambda (f x) (if (pair? x) (f x) x)))
         (scale-s (* (point-distance m0 m1) 1/3 (if cross-tangent-scaling? 1 tangent-scale)))
         (scale-h (if cross-tangent-scaling? tangent-scale 1))
         (scaled-relative (lambda (c f i)
                            (let ((i (select-from-pair f i)))
                              (v+ c (v* (v- (vector-ref offset-vertices i) c)
                                        scale-h)))))
         (o0 (scaled-relative m0 cdr (list-ref offset-face j)))
         (o1 (scaled-relative m1 car (list-ref offset-face j+1)))
         ;; the opposite face includes a vertex index from both c0 and c1
         (opp (find-opposite i (list-ref face j) c0 c1))
         (opp-1 (find-opposite i (list-ref face j) c0 (chamfer (list-ref face j-1))))
         (opp+1 (find-opposite i (list-ref face j+1) c1 (chamfer (list-ref face j+2))))
         (e0 (v* (v+ o0 (scaled-relative m0 car (common-element c0 opp))) 1/2))
         (e1 (v* (v+ o1 (scaled-relative m1 cdr (common-element c1 opp))) 1/2))
         (e0* (v+ m0 (v* (vnormalize (v- e0 m0)) scale-s)))
         (e1* (v+ m1 (v* (vnormalize (v- e1 m1)) scale-s)))
         (edge (cons (vector-ref vertices (list-ref face j))
                     (vector-ref vertices (list-ref face j+1))))
         (plane0 (chamfer-plane (list-ref face j)))
         (plane1 (chamfer-plane (list-ref face j+1)))
         (range0 (point-distance m0 (plane-line-intersection plane0 edge)))
         (range1 (point-distance m1 (plane-line-intersection plane1 edge)))
         (e0* (if (= (length fc0) 3)
                  (cdr (line-cutback (cons m0 e0*) range0))
                  e0*))
         (e1* (if (= (length fc1) 3)
                  (cdr (line-cutback (cons m1 e1*) range1))
                  e1*))
         (f0 (v* (v+ o0 (if (pair? (list-ref offset-face j))
                            (scaled-relative m0 car (list-ref offset-face j))
                            (scaled-relative m0 cdr (common-element c0 opp-1))))
                 1/2))
         (f1 (v* (v+ o1 (if (pair? (list-ref offset-face j+1))
                            (scaled-relative m1 cdr (list-ref offset-face j+1))
                            (scaled-relative m1 car (common-element c1 opp+1))))
                 1/2))
         (o0* (v+ f0 (v* (vnormalize (v- o0 f0)) (point-distance e0* m0))))
         (o1* (v+ f1 (v* (vnormalize (v- o1 f1)) (point-distance e1* m1))))
         (o0* (v+ e0* (v* (vnormalize (v- o0* e0*)) (point-distance f0 m0))))
         (o1* (v+ e1* (v* (vnormalize (v- o1* e1*)) (point-distance f1 m1))))
         )
    (cons (list m0 e0* e1* m1)
          (list f0 o0* o1* f1))))

;;; Computes a variation of r1 matching the mean cross-derivative with r2
(define (direction-blend r1 r2)
  (let* ((P0 (list-ref (car r1) 0))
         (P1 (list-ref (car r1) 1))
         (P2 (list-ref (car r1) 2))
         (P3 (list-ref (car r1) 3))
         (Ru0 (v* (v- P1 P0) 3))
         (Rv0 (v- (list-ref (cdr r1) 0) P0))
         (Sv0 (v- (list-ref (cdr r2) 3) P0))
         (Ru1 (v* (v- P3 P2) 3))
         (Rv1 (v- (list-ref (cdr r1) 3) P3))
         (Sv1 (v- (list-ref (cdr r2) 0) P3))
         (Rv05 (v* (v+ Rv0 (v* (v- (list-ref (cdr r1) 1) P1) 3)
                       Rv1 (v* (v- (list-ref (cdr r1) 2) P2) 3))
                   1/8))
         (Sv05 (v* (v+ Sv0 (v* (v- (list-ref (cdr r2) 2) P1) 3)
                       Sv1 (v* (v- (list-ref (cdr r2) 1) P2) 3))
                   1/8))
         (Mv0 (v* (v- Rv0 Sv0) 1/2))
         (Mv05 (v* (v- Rv05 Sv05) 1/2 midvector-scale))
         (Mv1 (v* (v- Rv1 Sv1) 1/2))
         (ab0 (in-system Rv0 Mv0 Ru0))
         (ab1 (in-system Rv1 Mv1 Ru1))
         (a0 (case direction-blend-type
               ((cubic-simple cubic-no-alpha) 1)
               (else (car ab0))))
         (a1 (case direction-blend-type
               ((cubic-simple cubic-no-alpha) 1)
               (else (car ab1))))
         (b0 (case direction-blend-type
               ((cubic-simple) 0)
               (else (cdr ab0))))
         (b1 (case direction-blend-type
               ((cubic-simple) 0)
               (else (cdr ab1))))
         (Q0 (v+ (v* Mv0 a0) (v* Ru0 b0)))
         (Q1 (v+ (v* Mv0 1/3 (- a1 a0)) (v* Mv05 4/3 a0) (v* Mv1 -1/3 a0)
                 (v* Ru0 1/3 b1) (v* (v- P2 P1) 2 b0)))
         (Q2 (v+ (v* Mv0 -1/3 a1) (v* Mv05 4/3 a1) (v* Mv1 1/3 (- a0 a1))
                 (v* (v- P2 P1) 2 b1) (v* Ru1 1/3 b0)))
         (Q3 (v+ (v* Mv1 a1) (v* Ru1 b1))))
    (cons (car r1)
          (map (lambda (p q) (v+ p q))
               (list P0 P1 P2 P3) (list Q0 Q1 Q2 Q3)))))

(define (direction-blend-cubic-tomi r1 r2)
  (cons (car r1)
        (map (lambda (p q1 q2)
               (v+ p (v* (v- q1 q2) 1/2)))
             (car r1) (cdr r1) (reverse (cdr r2)))))

(define (direction-blend-cubic-peti r1 r2)
  (cons (car r1)
        (map (lambda (p q1 q2)
               (let ((c (scalar-product (vnormalize (v- q1 p))
                                        (vnormalize (v- q2 p)))))
                 (v+ p (v* (v- q1 q2) (+ c 3/2)))))
             (car r1) (cdr r1) (reverse (cdr r2)))))

(define (find-chamfer-with-midpoint p)
  (let loop ((i 0))
    (if (= i (vector-length vertices))
        (error "cannot find chamfer")
        (let* ((c (chamfer i))
               (f (flatten-pairs c))
               (m (v* (apply v+ (map (lambda (v)
                                       (vector-ref offset-vertices v))
                                     f))
                      (/ (length f)))))
          (if (equal? m p)
              c
              (loop (+ i 1)))))))

(define (direction-blend-magic r1 r2)
  (define (get-scaling p)
    (if (= (length (flatten-pairs (find-chamfer-with-midpoint p))) 3)
        magic-constant
        1/2))
  (let* ((left (get-scaling (caar r1)))
         (right (get-scaling (caar r2))))
    (cons (car r1)
                (map (lambda (p q1 q2 s)
                       (v+ p (v* (v- q1 q2) s)))
                     (car r1) (cdr r1) (reverse (cdr r2))
                     `(,left 1/2 1/2 ,right)))))

(define (direction-blend-cubic-linear r1 r2)
  (bind-list (P00 P10 P20 P30) (car r1)
    (bind-list (P01 P11 P21 P31) (cdr r1)
      (let* ((left (v- P11 P10))
             (right (v- P21 P20))
             (quadratic (elevate (list left right))))
        (set-car! (cdr quadratic)
                  (v* (cadr quadratic) midvector-scale))
        (cons (car r1)
              (map (lambda (p q)
                     (v+ p q))
                   (car r1) (elevate quadratic)))))))

(define (direction-blend-cubic-linear-c0 r1 r2)
  (define (scale p q1 q2)
    (let ((c (scalar-product (vnormalize (v- q1 p)) (vnormalize (v- q2 p)))))
      (if (< c -0.99) 1/2 1)))
  (bind-list (P00 P10 P20 P30) (car r1)
    (bind-list (P01 P11 P21 P31) (cdr r1)
      (bind-list (P0-1 P1-1 P2-1 P3-1) (cdr r2)
        (let* ((left (v* (v- P01 P3-1) (scale P00 P01 P3-1)))
               (right (v* (v- P31 P0-1) (scale P30 P31 P0-1)))
               (quadratic (elevate (list left right))))
          (set-car! (cdr quadratic)
                    (v* (cadr quadratic) midvector-scale))
          (cons (car r1)
                (map (lambda (p q)
                       (v+ p q))
                     (car r1) (elevate quadratic))))))))

(define (elevate lst)
  (let ((n (length lst)))
    (let loop ((i 1) (cpts (list (car lst))) (lst lst))
      (if (= i n)
          (reverse (cons (car (reverse lst)) cpts))
          (loop (+ i 1)
                (cons (v+ (v* (car lst) (/ i n))
                          (v* (cadr lst) (- 1 (/ i n))))
                      cpts)
                (cdr lst))))))

(define (direction-blend-quartic r1 r2)
  (bind-list (P00 P10 P20 P30) (car r1)
    (bind-list (P01 P11 P21 P31) (cdr r1)
      (bind-list (P0-1 P1-1 P2-1 P3-1) (cdr r2)
        (let* ((quartic (elevate (car r1)))
               (P0 (v* (v- (list-ref quartic 1) (list-ref quartic 0)) 4))
               (P1 (v* (v- (list-ref quartic 2) (list-ref quartic 1)) 4))
               (P2 (v* (v- (list-ref quartic 3) (list-ref quartic 2)) 4))
               (P3 (v* (v- (list-ref quartic 4) (list-ref quartic 3)) 4))
               (Rv0 (v* (v- P01 P00) 3))
               (Rv1 (v* (v- P31 P30) 3))
               (Rbv0 (v* (v- P01 P3-1) 3/2))
               (Rbv1 (v* (v- P31 P0-1) 3/2))
               (Rbv05 (v* (v+ Rbv0 Rbv1 (v* (v+ (v- P11 P2-1) (v- P21 P1-1)) 9/2))
                          1/8 midvector-scale))
               (beta0 (case direction-blend-type
                        ((quartic-simple) 0)
                        (else (cdr (in-system Rv0 Rbv0 P0)))))
               (beta1 (case direction-blend-type
                        ((quartic-simple) 0)
                        (else (cdr (in-system Rv1 Rbv1 P3)))))
               (Q0 (v+ Rbv0 (v* P0 beta0)))
               (Q1 (v+ (v* (v+ Rbv0 Rbv05) 1/2)
                       (v* (v+ (v* P0 beta1) (v* P1 3 beta0)) 1/4)))
               (Q2 (v+ (v* (v+ Rbv0 (v* Rbv05 4) Rbv1) 1/6)
                       (v* (v+ (v* P1 beta1) (v* P2 beta0)) 1/2)))
               (Q3 (v+ (v* (v+ Rbv05 Rbv1) 1/2)
                       (v* (v+ (v* P2 3 beta1) (v* P3 beta0)) 1/4)))
               (Q4 (v+ Rbv1 (v* P3 beta1))))
          (cons quartic
                (let ((scale/d (if cubic-cross-degree? 1/3 1/4)))
                  (map (lambda (p q) (v+ p (v* q scale/d)))
                       quartic (list Q0 Q1 Q2 Q3 Q4)))))))))

(define (direction-blend-quartic-tomi r1 r2)
  (bind-list (P00 P10 P20 P30) (car r1)
    (bind-list (P01 P11 P21 P31) (cdr r1)
      (bind-list (P0-1 P1-1 P2-1 P3-1) (cdr r2)
        (let* ((quartic (let ((q (elevate (car r1))))
                          (list-set! q 2 (v* (v+ (list-ref q 1) (list-ref q 3)) 1/2))
                          q))
               (P0 (v* (v- (list-ref quartic 1) (list-ref quartic 0)) 4))
               (P1 (v* (v- (list-ref quartic 2) (list-ref quartic 1)) 4))
               (P2 (v* (v- (list-ref quartic 3) (list-ref quartic 2)) 4))
               (P3 (v* (v- (list-ref quartic 4) (list-ref quartic 3)) 4))
               (Rv0 (v* (v- P01 P00) 3))
               (Rv1 (v* (v- P31 P30) 3))
               (Rbv0 (v* (v- P01 P3-1) 3/2))
               (Rbv1 (v* (v- P31 P0-1) 3/2))
               (Rbv05 (v+ Rbv0 Rbv1))
               (beta0 (case direction-blend-type
                        ((quartic-tomi-simple) 0)
                        (else (cdr (in-system Rv0 Rbv0 P0)))))
               (beta1 (case direction-blend-type
                        ((quartic-tomi-simple) 0)
                        (else (cdr (in-system Rv1 Rbv1 P3)))))
               (Q0 (v+ Rbv0 (v* P0 beta0)))
               (Q1 (v+ (v* Rbv0 2)
                       (v* (v+ (v* P0 beta1) (v* P1 3 beta0)) 1/4)))
               (Q2 (v+ Rbv05
                       (v* (v+ (v* P1 beta1) (v* P2 beta0)) 1/2)))
               (Q3 (v+ (v* Rbv1 2)
                       (v* (v+ (v* P2 3 beta1) (v* P3 beta0)) 1/4)))
               (Q4 (v+ Rbv1 (v* P3 beta1))))
          (cons quartic
                (let ((scale/d (if cubic-cross-degree? 1/3 1/4)))
                  (map (lambda (p q) (v+ p (v* q scale/d)))
                       quartic (list Q0 Q1 Q2 Q3 Q4)))))))))

(define (direction-blend-quintic r1 r2)
  (bind-list (P00 P10 P20 P30) (car r1)
    (bind-list (P01 P11 P21 P31) (cdr r1)
      (bind-list (P0-1 P1-1 P2-1 P3-1) (cdr r2)
        (let* ((Ru0 (v* (v- P10 P00) 3))
               (Ru1 (v* (v- P30 P20) 3))
               (Rv0 (v* (v- P01 P00) 3))
               (Rv1 (v* (v- P31 P30) 3))
               (Rbv0 (v* (v- P01 P3-1) 3/2))
               (Rbv1 (v* (v- P31 P0-1) 3/2))
               (Rbv05 (v* (v+ Rbv0 Rbv1 (v* (v+ (v- P11 P2-1) (v- P21 P1-1)) 9/2))
                          1/8 midvector-scale))
               (ab0 (in-system Rv0 Ru0 Rbv0))
               (ab1 (in-system Rv1 Ru1 Rbv1))
               (ab*0 (in-system (v+ (v* (v+ (v- P11 P10) (v- P00 P01)) 36)
                                    (v* (v+ (v* P20 -2) (v* P10 7) (v* P00 -5)) 12 (car ab0))
                                    (v* (v+ P31 (v* P3-1 -11) (v* P21 -3) (v* P2-1 3)
                                            (v* P11 -3) (v* P1-1 3) (v* P01 11) (v* P0-1 -1))
                                        3 (cdr ab0)))
                                (v* (v- P10 P00) 36) (v* (v- P01 P3-1) 18)))
               (ab*1 (in-system (v+ (v* (v+ (v- P31 P30) (v- P20 P21)) 36)
                                    (v* (v+ (v* P30 -5) (v* P20 7) (v* P10 -2)) 12 (car ab1))
                                    (v* (v+ (v* P31 -11) P3-1 (v* P21 3) (v* P2-1 -3)
                                            (v* P11 3) (v* P1-1 -3) (v* P01 -1) (v* P0-1 11))
                                        3 (cdr ab1)))
                                (v* (v- P20 P30) 36) (v* (v- P0-1 P31) 18)))
               (Q0 (v+ (v* Rbv0 (cdr ab0)) (v* (v- P10 P00) 3 (car ab0))))
               (Q1 (v* (v+ (v* Rbv0 (- (* 3 (cdr ab*0)) (cdr ab0)))
                           (v* Rbv05 4 (cdr ab0))
                           (v* Rbv1 -1 (cdr ab0))
                           (v* (v- P10 P00) 9 (car ab*0))
                           (v* (v- P20 P10) 6 (car ab0)))
                       1/5))
               (Q2 (v* (v+ (v* Rbv0 3 (- (cdr ab*1) (cdr ab*0)))
                           (v* Rbv05 12 (cdr ab*0))
                           (v* Rbv1 (- (cdr ab0) (* 3 (cdr ab*0))))
                           (v* (v- P10 P00) 9 (car ab*1))
                           (v* (v- P20 P10) 18 (car ab*0))
                           (v* (v- P30 P20) 3 (car ab0)))
                       1/10))
               (Q3 (v* (v+ (v* Rbv0 (- (cdr ab1) (* 3 (cdr ab*1))))
                           (v* Rbv05 12 (cdr ab*1))
                           (v* Rbv1 3 (- (cdr ab*0) (cdr ab*1)))
                           (v* (v- P10 P00) 3 (car ab1))
                           (v* (v- P20 P10) 18 (car ab*1))
                           (v* (v- P30 P20) 9 (car ab*0)))
                       1/10))
               (Q4 (v* (v+ (v* Rbv0 -1 (cdr ab1))
                           (v* Rbv05 4 (cdr ab1))
                           (v* Rbv1 (- (* 3 (cdr ab*1)) (cdr ab1)))
                           (v* (v- P20 P10) 6 (car ab1))
                           (v* (v- P30 P20) 9 (car ab*1)))
                       1/5))
               (Q5 (v+ (v* Rbv1 (cdr ab1)) (v* (v- P30 P20) 3 (car ab1))))
               (quintic (elevate (elevate (car r1)))))
          (cons quintic
                (let ((scale/d (if cubic-cross-degree? 1/3 1/5)))
                  (map (lambda (p q) (v+ p (v* q scale/d)))
                       quintic (list Q0 Q1 Q2 Q3 Q4 Q5)))))))))

(define (direction-blend-quintic-tomi r1 r2)
  (bind-list (P00 P10 P20 P30) (car r1)
    (bind-list (P01 P11 P21 P31) (cdr r1)
      (bind-list (P0-1 P1-1 P2-1 P3-1) (cdr r2)
        (let* ((b0 (v* (v- P10 P00) 3))
               (b1 (v* (v- P20 P10) 3))
               (b2 (v* (v- P30 P20) 3))
               (a0 (v* (v- P01 P3-1) 3/2))
               (a1 (v* (v+ (v- P11 P2-1) (v- P21 P1-1)) 3/4 midvector-scale))
               (a2 (v* (v- P31 P0-1) 3/2))
               (q0 (v* (v- P01 P00) 3))
               (q1-cubic (v* (v- P11 P10) 3))
               (q1 (v+ (v* q0 2/5) (v* q1-cubic 3/5)))
               (q2-cubic (v* (v- P21 P20) 3))
               (q5 (v* (v- P31 P30) 3))
               (q4 (v+ (v* q5 2/5) (v* q2-cubic 3/5)))
               (ab0 (in-system q0 a0 b0))
               (ab3 (in-system q5 a2 b2))
               (ab1 (in-system (v+ (v* q1 5) (v* a1 -2 (car ab0)) (v* b1 -2 (cdr ab0)))
                               (v* a0 3) (v* b0 3)))
               (ab2 (in-system (v+ (v* q4 5) (v* a1 -2 (car ab3)) (v* b1 -2 (cdr ab3)))
                               (v* a2 3) (v* b2 3)))
               (c0 (v+ (v* a0 (car ab0)) (v* b0 (cdr ab0))))
               (c1 (v* (v+ (v* a0 3 (car ab1)) (v* a1 2 (car ab0))
                           (v* b0 3 (cdr ab1)) (v* b1 2 (cdr ab0)))
                       1/5))
               (c2 (v* (v+ (v* a0 3 (car ab2)) (v* a1 6 (car ab1)) (v* a2 (car ab0))
                           (v* b0 3 (cdr ab2)) (v* b1 6 (cdr ab1)) (v* b2 (cdr ab0)))
                       1/10))
               (c3 (v* (v+ (v* a0 (car ab3)) (v* a1 6 (car ab2)) (v* a2 3 (car ab1))
                           (v* b0 (cdr ab3)) (v* b1 6 (cdr ab2)) (v* b2 3 (cdr ab1)))
                       1/10))
               (c4 (v* (v+ (v* a1 2 (car ab3)) (v* a2 3 (car ab2))
                           (v* b1 2 (cdr ab3)) (v* b2 3 (cdr ab2)))
                       1/5))
               (c5 (v+ (v* a2 (car ab3)) (v* b2 (cdr ab3))))
               (quintic (elevate (elevate (car r1)))))
          (cons quintic
                (let ((scale/d (if cubic-cross-degree? 1/3 1/5)))
                  (map (lambda (p q) (v+ p (v* q scale/d)))
                       quintic (list c0 c1 c2 c3 c4 c5)))))))))

;;; Returns (face . side)
(define (opposite-side i j)
  (let* ((verts (nested-ref faces i))
         (n (length verts))
         (j+1 (modulo (+ j 1) n))
         (v0 (list-ref verts j))
         (v1 (list-ref verts j+1))
         (candidates (common-elements (vector-ref vertex-faces v0)
                                      (vector-ref vertex-faces v1)))
         (face (if (equal? (car candidates) i)
                   (cadr candidates)
                   (car candidates)))
         (side (find-index v1 (nested-ref faces face))))
    (cons face side)))

(define (fix-continuity ribbons)
  (let ((n (vector-length ribbons)))
    (do ((result (make-vector n))
         (i 0 (+ i 1)))
        ((= i n) result)
      (let ((loops (vector-ref ribbons i)))
        (vector-set!
         result i
         (map (lambda (face-ribbons l)
                (map (lambda (ribbon j)
                       (let* ((opp (opposite-side (cons i l) j))
                              (opp-face (nested-ref ribbons (car opp)))
                              (opp-ribbon (list-ref opp-face (cdr opp))))
                         ((case direction-blend-type
                            ((cubic-tomi-simple) direction-blend-cubic-tomi)
                            ((cubic-peti-simple) direction-blend-cubic-peti)
                            ((magic) direction-blend-magic)
                            ((cubic-linear) direction-blend-cubic-linear)
                            ((cubic-linear-c0) direction-blend-cubic-linear-c0)
                            ((quartic-simple quartic-no-alpha) direction-blend-quartic)
                            ((quartic-tomi-simple quartic-tomi-no-alpha)
                             direction-blend-quartic-tomi)
                            ((quintic) direction-blend-quintic)
                            ((quintic-tomi) direction-blend-quintic-tomi)
                            ((none) (lambda (x y) x))
                            (else direction-blend))
                          ribbon opp-ribbon)))
                     face-ribbons (range 0 (length face-ribbons))))
              loops (range 0 (length loops))))))))

(define (update-ribbons)
  (set! ribbons
    (do ((result (make-vector (vector-length faces)))
         (i 0 (+ i 1)))
        ((= i (vector-length faces))
         (fix-continuity result))
      (vector-set! result i
                   (let ((loops (vector-ref faces i)))
                     (map (lambda (l)
                            (let ((loop (list-ref loops l)))
                              (map (lambda (j)
                                     (generate-ribbon (cons i l) j))
                                   (range 0 (length loop)))))
                          (range 0 (length loops))))))))

(define (common-edge poly1 poly2)
  (define (find-first-tail ps)
    (if (member (car ps) poly2)
        ps
        (find-first-tail (cdr ps))))
  (let ((tail (find-first-tail poly1)))
    (cons (car tail)
          (car (find-first-tail (cdr tail))))))

(define (draw-lines)
  (set! misc-lines '())
  (do ((v 0 (+ v 1)))
      ((= v (vector-length vertices)))
    (let* ((indices (chamfer v))
           (n (length indices))
           (fc (flatten-pairs indices)))
      (when (= (length fc) 3)
        (let* ((A (vector-ref offset-vertices (list-ref fc 0)))
               (B (vector-ref offset-vertices (list-ref fc 1)))
               (C (vector-ref offset-vertices (list-ref fc 2)))
               (ea (point-distance B C))
               (eb (point-distance C A))
               (ec (point-distance A B))
               (s (/ (+ ea eb ec) 2))
               (area (/ (vlength (cross-product (v- B A) (v- C A))) 2))
               (radius (/ area s))
               (center (v* (v+ (v* A ea) (v* B eb) (v* C ec)) (/ 1/2 s)))
               (ta (v* (v+ (v* B (- s ec)) (v* C (- s eb))) (/ ea)))
               (tb (v* (v+ (v* C (- s ea)) (v* A (- s ec))) (/ eb)))
               (tc (v* (v+ (v* A (- s eb)) (v* B (- s ea))) (/ ec))))
          (set! misc-lines
            (append (list (cons center ta)
                          (cons center tb)
                          (cons center tc))
                    misc-lines)))))))


;;; Main function

(define (load-model filename)
  (let ((model (read-obj filename)))
    (set! vertices (car model))
    (set! faces (cadr model)))
  (update-topology)
  (update-offsets)
  (update-chamfer-scalings)
  (draw-lines)
  (update-ribbons))
