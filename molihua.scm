;;; Parameters (for debugging/experiments etc.)


;;; Global variables
(define vertices #f)
(define faces #f)
(define offset-vertices #f)
(define offset-faces #f)
(define vertex-faces #f)
(define ribbons #f)


;;; R7RS compatibility
(cond-expand
  (guile
   (use-modules (ice-9 rdelim))         ; read-line
   (define (vector-map f v)
     (let ((len (vector-length v)))
       (do ((result (make-vector len))
            (i 0 (+ i 1)))
           ((= i len) result)
         (vector-set! result i (f (vector-ref v i))))))
   (define (vector-for-each f v)
     (let ((len (vector-length v)))
       (do ((i 0 (+ i 1)))
           ((= i len))
         (f (vector-ref v i))))))
  (gambit))


;;; General utilities

(define-syntax bind-list
  (syntax-rules ()
    ((_ vars lst body ...)
     (apply (lambda vars body ...) lst))))

;;; `x` is assumed to be in `lst`;
;;; this gives the next element (first if `x` is last)
(define (next-element lst x)
  (let loop ((rest lst))
    (cond ((null? (cdr rest)) (car lst))
          ((eq? (car rest) x) (cadr rest))
          (else (loop (cdr rest))))))

(define (prev-element lst x)
  (next-element (reverse lst) x))

(define (flatten-pairs lst)
  (cond ((null? lst)
         '())
        ((pair? (car lst))
         (cons (caar lst)
               (cons (cdar lst)
                     (flatten-pairs (cdr lst)))))
        (else
         (cons (car lst)
               (flatten-pairs (cdr lst))))))

;;; Brings the last element to the beginning
(define (rotate lst)
  (let loop ((lst lst) (acc '()))
    (if (null? (cdr lst))
        (append lst (reverse acc))
        (loop (cdr lst) (cons (car lst) acc)))))

;;; Split by spaces; multiple spaces count as one.
;;; Newlines are also count as spaces; starting/ending spaces are discounted.
;;; Trim chunks starting with '/' characters.
(define (split-string s)
  (define (stringify-car! lst)
    (set-car! lst (list->string (reverse (car lst)))))
  (do ((result (list (list)))
       (skip #f)
       (lst (string->list s) (cdr lst)))
      ((null? lst)
       (if (null? (car result))
           (set! result (cdr result))
           (stringify-car! result))
       (reverse result))
    (case (car lst)
      ((#\space #\return #\newline)
       (unless (null? (car result))
         (stringify-car! result)
         (set! result (cons (list) result))
         (set! skip #f)))
      ((#\/)
       (set! skip #t))
      (else (unless skip
              (set-car! result
                        (cons (car lst) (car result))))))))

;;; List of integers (from .. end-1)
(define (range from end)
  (let loop ((from from))
    (if (= from end)
        '()
        (cons from (loop (+ from 1))))))

(define (find-index elt lst)
  (let loop ((i 0) (lst lst))
    (cond ((null? lst) #f)
          ((eq? (car lst) elt) i)
          (else (loop (+ i 1) (cdr lst))))))

(define (common-element a b)
  (let loop ((a a))
    (cond ((null? a) #f)
          ((member (car a) b) (car a))
          (else (loop (cdr a))))))

(define (common-elements a b)
  (let loop ((a a))
    (cond ((null? a) '())
          ((member (car a) b)
           (cons (car a) (loop (cdr a))))
          (else (loop (cdr a))))))

(define (disjoint? a b)
  (eq? (common-element a b) #f))

;;; Finds a list in lst (a list of lists) that has
;;; common elements with both a and b (both lists).
(define (find-connection a b lst)
  (let loop ((lst lst))
    (cond ((null? lst) #f)
          ((or (disjoint? (car lst) a)
               (disjoint? (car lst) b))
           (loop (cdr lst)))
          (else (car lst)))))


;;; I/O routines

(define (read-obj filename)
  (with-input-from-file filename
    (lambda ()
      (do ((v '())
           (f '())
           (line (read-line) (read-line)))
          ((eof-object? line)
           (cons (list->vector (reverse v))
                 (list->vector (reverse f))))
        (let ((type (or (and (< (string-length line) 2) "")
                        (substring line 0 2))))
          (cond ((string-ci=? type "v ")
                 (let ((vertex (map string->number (cdr (split-string line)))))
                   (set! v (cons vertex v))))
                ((string-ci=? type "f ")
                 (let ((face (map (lambda (s)
                                    (- (string->number s) 1))
                                  (cdr (split-string line)))))
                   (set! f (cons face f))))))))))

(define (write-vertex v)
  (display "v")
  (for-each (lambda (xyz)
              (display " ")
              (display xyz))
            v)
  (newline))

(define (write-offsets filename)
  (with-output-to-file filename
    (lambda ()
      (vector-for-each write-vertex offset-vertices)
      (let ((write-face (lambda (face)
                          (display "f")
                          (for-each (lambda (v)
                                      (cond ((pair? v)
                                             (display " ")
                                             (display (+ (car v) 1))
                                             (display " ")
                                             (display (+ (cdr v) 1)))
                                            (else
                                             (display " ")
                                             (display (+ v 1)))))
                                    face)
                          (newline))))
        (if only-one-patch
            (write-face (vector-ref offset-faces only-one-patch))
            (vector-for-each write-face offset-faces))))))

(define (write-chamfers filename)
  (with-output-to-file filename
    (lambda ()
      (vector-for-each write-vertex offset-vertices)
      (let ((write-chamfer (lambda (i)
                             (display "f")
                             (for-each (lambda (v)
                                         (cond ((pair? v)
                                                (display " ")
                                                (display (+ (cdr v) 1))
                                                (display " ")
                                                (display (+ (car v) 1)))
                                               (else
                                                (display " ")
                                                (display (+ v 1)))))
                                       (chamfer i))
                             (newline))))
        (if only-one-patch
            (for-each write-chamfer (vector-ref faces only-one-patch))
            (do ((i 0 (+ i 1)))
                ((= i (vector-length vertices)))
              (write-chamfer i)))))))

;;; Show ribbon in Obj format;
;;; index is the number of already printed vertices.
;;; Returns the new index.
(define (show-ribbon ribbon index)
  (for-each write-vertex (append (car ribbon) (cdr ribbon)))
  (let ((line (lambda (indices)
                (display "l")
                (for-each (lambda (v)
                            (display " ")
                            (display (+ index v)))
                          indices)
                (newline))))
    (line '(1 2 3 4))
    (line '(5 6 7 8))
    (line '(1 5))
    (line '(2 6))
    (line '(3 7))
    (line '(4 8)))
  (+ index 8))

(define (write-controls filename)
  (with-output-to-file filename
    (lambda ()
      (do ((index 0)
           (i 0 (+ i 1)))
          ((= i (vector-length faces)))
        (when (or (not only-one-patch)
                  (= only-one-patch i))
          (for-each (lambda (ribbon)
                      (set! index (show-ribbon ribbon index)))
                    (vector-ref ribbons i)))))))

(define (knot-string degree with-size?)
  (parameterize ((current-output-port (open-output-string)))
    (when with-size?
      (display (* (+ degree 1) 2))
      (display " "))
    (do ((i 0 (+ i 1)))
        ((> i degree))
      (display "0 "))
    (do ((i 0 (+ i 1)))
        ((= i degree) (display 1))
      (display "1 "))
    (get-output-string (current-output-port))))

(define (write-patches-mgbs filename-prefix)
  (do ((index 0)
       (i 0 (+ i 1)))
      ((= i (vector-length faces)))
    (when (or (not only-one-patch)
              (= only-one-patch i))
      (with-output-to-file
          (string-append filename-prefix (number->string (+ i 1)) ".mgbs")
        (lambda ()
          (let ((n (length (vector-ref faces i))))
            (display 1) (newline)       ; # of loops
            (display n) (newline)       ; # of sides
            (for-each (lambda (ribbon)
                        (let ((deg (- (length (car ribbon)) 1)))
                          (display deg) (display " ") ; s-deg
                          (display deg) (display " ") ; h-deg
                          (display "2 0") (newline)   ; layers ribcp?
                          (display (knot-string deg #f)) (newline)) ; s-knots
                        (for-each (lambda (p)
                                    (display (car p)) (display " ")
                                    (display (cadr p)) (display " ")
                                    (display (caddr p)) (newline))
                                  (append (car ribbon) (cdr ribbon))))
                      (vector-ref ribbons i))
            (display "400 200") (newline))))))) ; curve-res triangle-res

(define (write-qds ribbons filename)
  (with-output-to-file filename
    (lambda ()
      (display (length ribbons))
      (newline)
      (for-each (lambda (ribbon)
                  (let ((deg (- (length (car ribbon)) 1)))
                    (display "1 ") (display deg) (newline)
                    (display "4 0 0 1 1") (newline)
                    (display (knot-string deg #t)) (newline)
                    )
                  (for-each (lambda (p)
                              (display (car p)) (display " ")
                              (display (cadr p)) (display " ")
                              (display (caddr p)) (newline))
                            (append (car ribbon) (cdr ribbon))))
                ribbons))))


;;; Geometry procedures

(define (v+ . args)
  (apply map + args))

(define (v- . args)
  (apply map - args))

(define (v* u . args)
  (map (lambda (x) (apply * x args)) u))

(define (scalar-product u v)
  (apply + (map * u v)))

(define (cross-product u v)
  (list (- (* (cadr u) (caddr v)) (* (caddr u) (cadr v)))
	(- (* (caddr u) (car v)) (* (car u) (caddr v)))
	(- (* (car u) (cadr v)) (* (cadr u) (car v)))))

(define (vlength u)
  (sqrt (scalar-product u u)))

(define (vnormalize u)
  (v* u (/ (vlength u))))

;;; Returns (a . b) such that u = v a + w b.
(define (in-system u v w)
  (let ((v2 (scalar-product v v))
        (w2 (scalar-product w w))
        (uv (scalar-product u v))
        (uw (scalar-product u w))
        (vw (scalar-product v w)))
    (let ((denom (- (* v2 w2) (* vw vw))))
      (cons (/ (- (* w2 uv) (* vw uw)) denom)
            (/ (- (* v2 uw) (* vw uv)) denom)))))

(define (point-distance p q)
  (vlength (v- q p)))

;;; Line is given as (point . point)
(define (line-point-distance line p)
  (let* ((q1 (car line))
         (q2 (cdr line))
         (v (v- p q1))
         (d (v- q2 q1)))
    (vlength (v- v (v* d (/ (scalar-product v d)
                            (scalar-product d d)))))))

;;; Pushes the line towards the point by `offset` part of their distance
(define (push-line line point offset)
  (let ((d (v* (v- point (car line)) offset)))
    (cons (v+ (car line) d)
          (v+ (cdr line) d))))

(define (line-line-intersection l1 l2)
  (let* ((ap (car l1))
         (ad (v- (cdr l1) (car l1)))
         (bp (car l2))
         (bd (v- (cdr l2) (car l2)))
         (a (scalar-product ad ad))
         (b (scalar-product ad bd))
         (c (scalar-product bd bd))
         (d (scalar-product ad (v- ap bp)))
         (e (scalar-product bd (v- ap bp))))
    (let ((denom (- (* a c) (* b b))))
      (if (< denom 1e-10)
          (error "parallel lines")
          (let ((s (/ (- (* b e) (* c d)) denom))
                (t (/ (- (* a e) (* b d)) denom)))
            (v* (v+ ap (v* ad s) bp (v* bd t)) 0.5))))))

(define (intersecting-segments? l1 l2)
  (let* ((ap (car l1))
         (ad (v- (cdr l1) (car l1)))
         (bp (car l2))
         (bd (v- (cdr l2) (car l2)))
         (a (scalar-product ad ad))
         (b (scalar-product ad bd))
         (c (scalar-product bd bd))
         (d (scalar-product ad (v- ap bp)))
         (e (scalar-product bd (v- ap bp))))
    (let ((denom (- (* a c) (* b b))))
      (if (< denom 1e-7)
          (and (< (vlength (cross-product bd (v- ap bp))) 1e-4) ; on the same line
               (not (or (< (scalar-product (v- (cdr l1) bp) ad) 0)
                        (< (scalar-product (v- (cdr l2) ap) ad) 0))))
          (let ((s (/ (- (* b e) (* c d)) denom))
                (t (/ (- (* a e) (* b d)) denom)))
            (and (<= 0 s 1) (<= 0 t 1)
                 (< (point-distance (v+ ap (v* ad s))
                                    (v+ bp (v* bd t)))
                    1e-5)))))))

(define (closest-vertex line verts)
  (let loop ((best #f) (dist #f) (lst verts))
    (cond ((null? lst) best)
          ((or (equal? (car line) (car lst))
               (equal? (cdr line) (car lst)))
           (loop best dist (cdr lst)))
          (else (let ((d (line-point-distance line (car lst))))
                  (if (or (not dist) (< d dist))
                      (loop (car lst) d (cdr lst))
                      (loop best dist (cdr lst))))))))

(define (out-normal line1 line2)
  (let* ((d1 (v- (cdr line1) (car line1)))
         (d2 (v- (cdr line2) (car line2))))
    (cross-product d1 d2)))

(define (concave-corner? line1 line2 normal)
  (< (scalar-product normal (out-normal line1 line2)) 0))

;;; A vertex is reachable if:
;;; - it is not one of the endpoints of `line`
;;; - the triangle defined by `line` and the vertex (i.e., l1 l2 p)
;;;   has correct orientation (w.r.t. `normal`)
;;; - the segments (l1 p) and (l2 p) do not intersect other segments
;;;   (but can be exactly one of `lines`)
(define (reachable-vertices line verts lines normal)
  (define (intersecting? segment)
    (let loop ((lst lines))
      (cond ((null? lst) #f)
            ((or (equal? (car segment) (caar lst))
                 (equal? (car segment) (cdar lst))
                 (equal? (cdr segment) (caar lst))
                 (equal? (cdr segment) (cdar lst)))
             (loop (cdr lst)))
            ((intersecting-segments? segment (car lst)) #t)
            (else (loop (cdr lst))))))
  (filter (lambda (v)
            (not (or (equal? v (car line))
                     (equal? v (cdr line))
                     (concave-corner? line (cons (cdr line) v) normal)
                     (intersecting? (cons v (car line)))
                     (intersecting? (cons (cdr line) v)))))
          verts))

;;; Assumes that the first corner is not concave
(define (offset-face verts)
  (let* ((lines (map cons verts (append (cdr verts) (list (car verts)))))
         (n (face-normal verts))
         (points (map (lambda (l)
                        (closest-vertex l (reachable-vertices l verts lines n)))
                      lines))
         (offsets (map (lambda (l p) (push-line l p (/ fullness 2))) lines points)))
    (let loop ((l1 (rotate lines)) (l2 lines)
               (o1 (rotate offsets)) (o2 offsets))
      (cond ((null? l1)
             '())
            ((concave-corner? (car l1) (car l2) n)
             (cons (list 'concave
                         (line-line-intersection (car o1) (car l2))
                         (line-line-intersection (car o2) (car l1)))
                   (loop (cdr l1) (cdr l2) (cdr o1) (cdr o2))))
            (else
             (cons (line-line-intersection (car o1) (car o2))
                   (loop (cdr l1) (cdr l2) (cdr o1) (cdr o2))))))))

;;; Returns (verts* . faces*)
(define (generate-offsets vertices faces)
  (do ((rfaces (make-vector (vector-length faces)))
       (rvertices '())
       (index 0)
       (i 0 (+ i 1)))
      ((= i (vector-length faces))
       (cons (list->vector (reverse rvertices)) rfaces))
    (let* ((off (offset-face
                 (map (lambda (v)
                        (vector-ref vertices v))
                      (vector-ref faces i))))
           (flat (apply append (map (lambda (x)
                                      (if (eq? (car x) 'concave)
                                          (cdr x)
                                          (list x)))
                                    off)))
           (n (length flat)))
      (set! rvertices (append (reverse flat) rvertices))
      (vector-set! rfaces i
                   (let loop ((lst off) (i index))
                     (cond ((null? lst)
                            '())
                           ((eq? (caar lst) 'concave)
                            (cons (cons i (+ i 1))
                                  (loop (cdr lst) (+ i 2))))
                           (else
                            (cons i (loop (cdr lst) (+ i 1)))))))
      (set! index (+ index n)))))

(define (update-topology)
  (set! vertex-faces
    (do ((result (make-vector (vector-length vertices) '()))
         (i 0 (+ i 1)))
        ((= i (vector-length faces))
         (let loop ((j (- (vector-length result) 1)) (acc '()))
           (if (< j 0)
               (list->vector acc)
               (loop (- j 1)
                     (cons (fix-order-around j (vector-ref result j))
                           acc)))))
      (for-each (lambda (v)
                  (vector-set! result v
                               (cons i (vector-ref result v))))
                (vector-ref faces i)))))

(define (update-offsets)
  (let ((offsets (generate-offsets vertices faces)))
    (set! offset-vertices (car offsets))
    (set! offset-faces (cdr offsets))))

;;; Moves the adjacent face to the beginning
;;; Adjacency means that there is (u v) in one, and (v u) in the other
(define (select-adjacent v face lst)
  (let loop ((lst lst) (acc '()))
    (cond ((null? lst)
           (error "cannot find adjacent face"))
          ((let ((a (vector-ref faces face))
                 (b (vector-ref faces (car lst))))
             (or (= (next-element a v) (prev-element b v))
                 (= (prev-element a v) (next-element b v))))
           (cons (car lst) (append acc (cdr lst))))
          (else
           (loop (cdr lst) (cons (car lst) acc))))))

;;; Permute the list of faces to be cyclic
(define (fix-order-around v faces)
  (let loop ((lst faces))
    (if (null? (cdr lst))
        lst
        (cons (car lst)
              (loop (select-adjacent v (car lst) (cdr lst)))))))

;;; Sum the cross products of each edge endpoints & normalize
(define (face-normal points)
  (let ((edges (map cons points (append (cdr points) (list (car points))))))
    (vnormalize
     (let loop ((lst edges))
       (if (null? lst)
           '(0 0 0)
           (v+ (cross-product (caar lst) (cdar lst))
               (loop (cdr lst))))))))

;;; Returns the chamfer associated with the v-th vertex.
;;; The result is a list of indices to offset-vertices.
(define (chamfer v)
  (let* ((face-indices (vector-ref vertex-faces v))
         (lst (map (lambda (f)
                     (list-ref (vector-ref offset-faces f)
                               (find-index v (vector-ref faces f))))
                   face-indices))
         (face (map (lambda (v) (vector-ref vertices v))
                    (vector-ref faces (car face-indices))))
         (chamfer-face (map (lambda (v)
                              (if (pair? v)
                                  (v* (v+ (vector-ref offset-vertices (car v))
                                          (vector-ref offset-vertices (cdr v)))
                                      1/2)
                                  (vector-ref offset-vertices v)))
                            lst)))
    (if (< (scalar-product (face-normal face)
                           (face-normal chamfer-face))
           0)
        (reverse lst)
        lst)))

(define (shrink-chamfer! v)
  (let ((p (vector-ref vertices v)))
    (let ((d (let loop ((lst (chamfer v)))
               (cond ((null? lst) +inf.0)
                     ((pair? (car lst))
                      (let ((a (vector-ref offset-vertices (caar lst)))
                            (b (vector-ref offset-vertices (cdar lst))))
                        (min (point-distance a p)
                             (point-distance b p)
                             (loop (cdr lst)))))
                     (else
                      (min (point-distance (vector-ref offset-vertices (car lst)) p)
                           (loop (cdr lst))))))))
      (let* ((pull-back (lambda (q)
                          (v+ p (v* (vnormalize (v- q p)) d))))
             (pull-back! (lambda (i)
                           (vector-set! offset-vertices i
                                        (pull-back (vector-ref offset-vertices i))))))
        (for-each (lambda (i)
                    (cond ((pair? i)
                           (pull-back! (car i))
                           (pull-back! (cdr i)))
                          (else
                           (pull-back! i))))
                  (chamfer v))))))

;;; At vertex j with chamfer c0, find the face connecting to chamfer c1,
;;; which is the opposite of face i (i.e., not face i).
(define (find-opposite i j c0 c1)
  (let ((candidates
         (let loop ((lst (vector-ref vertex-faces j)))
           (cond ((null? lst) '())
                 ((= (car lst) i) (loop (cdr lst)))
                 (else (cons (vector-ref offset-faces (car lst))
                             (loop (cdr lst))))))))
    (or (find-connection c0 c1 candidates)
        (error "no opposite face"))))

;;; Face i side j
;;; m: chamfer midpoint
;;; o: chamfer vertex in the current face
;;; e: chamfer midpoint between the current and opposite faces
;;; f: chamfer midpoint between the current and adjacent-opposite faces
(define (generate-ribbon i j)
  (let* ((face (vector-ref faces i))
         (offset-face (vector-ref offset-faces i))
         (n (length face))
         (j-1 (modulo (- j 1) n))
         (j+1 (modulo (+ j 1) n))
         (j+2 (modulo (+ j 2) n))
         (c0 (chamfer (list-ref face j)))
         (c1 (chamfer (list-ref face j+1)))
         (fc0 (flatten-pairs c0))
         (fc1 (flatten-pairs c1))
         (m0 (v* (apply v+ (map (lambda (v)
                                  (vector-ref offset-vertices v))
                                fc0))
                 (/ (length fc0))))
         (m1 (v* (apply v+ (map (lambda (v)
                                  (vector-ref offset-vertices v))
                                fc1))
                 (/ (length fc1))))
         (select-from-pair (lambda (f x) (if (pair? x) (f x) x)))
         (scaled-offset (lambda (c f i)
                          (let ((i (select-from-pair f i)))
                            (v+ c (v* (v- (vector-ref offset-vertices i) c)
                                            tangent-scale)))))
         (o0 (scaled-offset m0 cdr (list-ref offset-face j)))
         (o1 (scaled-offset m1 car (list-ref offset-face j+1)))
         ;; the opposite face includes a vertex index from both c0 and c1
         (opp (find-opposite i (list-ref face j) c0 c1))
         (opp-1 (find-opposite i (list-ref face j) c0 (chamfer (list-ref face j-1))))
         (opp+1 (find-opposite i (list-ref face j+1) c1 (chamfer (list-ref face j+2))))
         (e0 (v* (v+ o0 (scaled-offset m0 car (common-element c0 opp))) 1/2))
         (e1 (v* (v+ o1 (scaled-offset m1 cdr (common-element c1 opp))) 1/2))
         (f0 (v* (v+ o0 (if (pair? (list-ref offset-face j))
                            (scaled-offset m0 car (list-ref offset-face j))
                            (scaled-offset m0 cdr (common-element c0 opp-1))))
                 1/2))
         (f1 (v* (v+ o1 (if (pair? (list-ref offset-face j+1))
                            (scaled-offset m1 cdr (list-ref offset-face j+1))
                            (scaled-offset m1 car (common-element c1 opp+1))))
                 1/2)))
    (cons (list m0 e0 e1 m1)
          (list f0 o0 o1 f1))))

;;; Computes a variation of r1 matching the mean cross-derivative with r2
(define (direction-blend r1 r2)
  (let* ((P0 (list-ref (car r1) 0))
         (P1 (list-ref (car r1) 1))
         (P2 (list-ref (car r1) 2))
         (P3 (list-ref (car r1) 3))
         (Ru0 (v* (v- P1 P0) 3))
         (Rv0 (v- (list-ref (cdr r1) 0) P0))
         (Sv0 (v- (list-ref (cdr r2) 3) P0))
         (Ru1 (v* (v- P3 P2) 3))
         (Rv1 (v- (list-ref (cdr r1) 3) P3))
         (Sv1 (v- (list-ref (cdr r2) 0) P3))
         (Rv05 (v* (v+ Rv0 (v* (v- (list-ref (cdr r1) 1) P1) 3)
                       Rv1 (v* (v- (list-ref (cdr r1) 2) P2) 3))
                   1/8))
         (Sv05 (v* (v+ Sv0 (v* (v- (list-ref (cdr r2) 2) P1) 3)
                       Sv1 (v* (v- (list-ref (cdr r2) 1) P2) 3))
                   1/8))
         (Mv0 (v* (v- Rv0 Sv0) 1/2))
         (Mv05 (v* (v- Rv05 Sv05) 1/2 midvector-scale))
         (Mv1 (v* (v- Rv1 Sv1) 1/2))
         (ab0 (in-system Rv0 Mv0 Ru0))
         (ab1 (in-system Rv1 Mv1 Ru1))
         (a0 (case direction-blend-type
               ((cubic-simple cubic-no-alpha) 1)
               (else (car ab0))))
         (a1 (case direction-blend-type
               ((cubic-simple cubic-no-alpha) 1)
               (else (car ab1))))
         (b0 (case direction-blend-type
               ((cubic-simple) 0)
               (else (cdr ab0))))
         (b1 (case direction-blend-type
               ((cubic-simple) 0)
               (else (cdr ab1))))
         (Q0 (v+ (v* Mv0 a0) (v* Ru0 b0)))
         (Q1 (v+ (v* Mv0 1/3 (- a1 a0)) (v* Mv05 4/3 a0) (v* Mv1 -1/3 a0)
                 (v* Ru0 1/3 b1) (v* (v- P2 P1) 2 b0)))
         (Q2 (v+ (v* Mv0 -1/3 a1) (v* Mv05 4/3 a1) (v* Mv1 1/3 (- a0 a1))
                 (v* (v- P2 P1) 2 b1) (v* Ru1 1/3 b0)))
         (Q3 (v+ (v* Mv1 a1) (v* Ru1 b1))))
    (cons (car r1)
          (map (lambda (p q) (v+ p q))
               (list P0 P1 P2 P3) (list Q0 Q1 Q2 Q3)))))

(define (elevate lst)
  (let ((n (length lst)))
    (let loop ((i 1) (cpts (list (car lst))) (lst lst))
      (if (= i n)
          (reverse (cons (car (reverse lst)) cpts))
          (loop (+ i 1)
                (cons (v+ (v* (car lst) (/ i n))
                          (v* (cadr lst) (- 1 (/ i n))))
                      cpts)
                (cdr lst))))))

(define (direction-blend-quartic r1 r2)
  (bind-list (P00 P10 P20 P30) (car r1)
    (bind-list (P01 P11 P21 P31) (cdr r1)
      (bind-list (P0-1 P1-1 P2-1 P3-1) (cdr r2)
        (let* ((quartic (elevate (car r1)))
               (P0 (v* (v- (list-ref quartic 1) (list-ref quartic 0)) 4))
               (P1 (v* (v- (list-ref quartic 2) (list-ref quartic 1)) 4))
               (P2 (v* (v- (list-ref quartic 3) (list-ref quartic 2)) 4))
               (P3 (v* (v- (list-ref quartic 4) (list-ref quartic 3)) 4))
               (Rv0 (v* (v- P01 P00) 3))
               (Rv1 (v* (v- P31 P30) 3))
               (Rbv0 (v* (v- P01 P3-1) 3/2))
               (Rbv1 (v* (v- P31 P0-1) 3/2))
               (Rbv05 (v* (v+ Rbv0 Rbv1 (v* (v+ (v- P11 P2-1) (v- P21 P1-1)) 9/2))
                          1/8 midvector-scale))
               (beta0 (case direction-blend-type
                        ((quartic-simple) 0)
                        (else (cdr (in-system Rv0 Rbv0 P0)))))
               (beta1 (case direction-blend-type
                        ((quartic-simple) 0)
                        (else (cdr (in-system Rv1 Rbv1 P3)))))
               (Q0 (v+ Rbv0 (v* P0 beta0)))
               (Q1 (v+ (v* (v+ Rbv0 Rbv05) 1/2)
                       (v* (v+ P0 (v* P1 3)) beta0 1/4)))
               (Q2 (v+ (v* (v+ Rbv0 (v* Rbv05 4) Rbv1) 1/6)
                       (v* (v+ (v* P1 3 beta1) (v* P2 3 beta0)) 1/6)))
               (Q3 (v+ (v* (v+ Rbv05 Rbv1) 1/2)
                       (v* (v+ (v* P2 3) P3) beta1 1/4)))
               (Q4 (v+ Rbv1 (v* P3 beta1))))
          (cons quartic
                (let ((scale/d (if cubic-cross-degree? 1/3 1/4)))
                  (map (lambda (p q) (v+ p (v* q scale/d)))
                       quartic (list Q0 Q1 Q2 Q3 Q4)))))))))

(define (direction-blend-quartic-tomi r1 r2)
  (bind-list (P00 P10 P20 P30) (car r1)
    (bind-list (P01 P11 P21 P31) (cdr r1)
      (bind-list (P0-1 P1-1 P2-1 P3-1) (cdr r2)
        (let* ((quartic (let ((q (elevate (car r1))))
                          (list-set! q 2 (v* (v+ (list-ref q 1) (list-ref q 3)) 1/2))
                          q))
               (P0 (v* (v- (list-ref quartic 1) (list-ref quartic 0)) 4))
               (P1 (v* (v- (list-ref quartic 2) (list-ref quartic 1)) 4))
               (P2 (v* (v- (list-ref quartic 3) (list-ref quartic 2)) 4))
               (P3 (v* (v- (list-ref quartic 4) (list-ref quartic 3)) 4))
               (Rv0 (v* (v- P01 P00) 3))
               (Rv1 (v* (v- P31 P30) 3))
               (Rbv0 (v* (v- P01 P3-1) 3/2))
               (Rbv1 (v* (v- P31 P0-1) 3/2))
               (Rbv05 (v+ Rbv0 Rbv1))
               (beta0 (case direction-blend-type
                        ((quartic-tomi-simple) 0)
                        (else (cdr (in-system Rv0 Rbv0 P0)))))
               (beta1 (case direction-blend-type
                        ((quartic-tomi-simple) 0)
                        (else (cdr (in-system Rv1 Rbv1 P3)))))
               (Q0 (v+ Rbv0 (v* P0 beta0)))
               (Q1 (v+ (v* Rbv0 2)
                       (v* (v+ P0 (v* P1 3)) beta0 1/4)))
               (Q2 (v+ Rbv05
                       (v* (v+ (v* P1 3 beta1) (v* P2 3 beta0)) 1/6)))
               (Q3 (v+ (v* Rbv1 2)
                       (v* (v+ (v* P2 3) P3) beta1 1/4)))
               (Q4 (v+ Rbv1 (v* P3 beta1))))
          (cons quartic
                (let ((scale/d (if cubic-cross-degree? 1/3 1/4)))
                  (map (lambda (p q) (v+ p (v* q scale/d)))
                       quartic (list Q0 Q1 Q2 Q3 Q4)))))))))

(define (direction-blend-quintic r1 r2)
  (bind-list (P00 P10 P20 P30) (car r1)
    (bind-list (P01 P11 P21 P31) (cdr r1)
      (bind-list (P0-1 P1-1 P2-1 P3-1) (cdr r2)
        (let* ((Ru0 (v* (v- P10 P00) 3))
               (Ru1 (v* (v- P30 P20) 3))
               (Rv0 (v* (v- P01 P00) 3))
               (Rv1 (v* (v- P31 P30) 3))
               (Rbv0 (v* (v- P01 P3-1) 3/2))
               (Rbv1 (v* (v- P31 P0-1) 3/2))
               (Rbv05 (v* (v+ Rbv0 Rbv1 (v* (v+ (v- P11 P2-1) (v- P21 P1-1)) 9/2))
                          1/8 midvector-scale))
               (ab0 (in-system Rv0 Ru0 Rbv0))
               (ab1 (in-system Rv1 Ru1 Rbv1))
               (ab*0 (in-system (v+ (v* (v+ (v- P11 P10) (v- P00 P01)) 36)
                                    (v* (v+ (v* P20 -2) (v* P10 7) (v* P00 -5)) 12 (car ab0))
                                    (v* (v+ P31 (v* P3-1 -11) (v* P21 -3) (v* P2-1 3)
                                            (v* P11 -3) (v* P1-1 3) (v* P01 11) (v* P0-1 -1))
                                        3 (cdr ab0)))
                                (v* (v- P10 P00) 36) (v* (v- P01 P3-1) 18)))
               (ab*1 (in-system (v+ (v* (v+ (v- P31 P30) (v- P20 P21)) 36)
                                    (v* (v+ (v* P30 -5) (v* P20 7) (v* P10 -2)) 12 (car ab1))
                                    (v* (v+ (v* P31 -11) P3-1 (v* P21 3) (v* P2-1 -3)
                                            (v* P11 3) (v* P1-1 -3) (v* P01 -1) (v* P0-1 11))
                                        3 (cdr ab1)))
                                (v* (v- P20 P30) 36) (v* (v- P0-1 P31) 18)))
               (Q0 (v+ (v* Rbv0 (cdr ab0)) (v* (v- P10 P00) 3 (car ab0))))
               (Q1 (v* (v+ (v* Rbv0 (- (* 3 (cdr ab*0)) (cdr ab0)))
                           (v* Rbv05 4 (cdr ab0))
                           (v* Rbv1 -1 (cdr ab0))
                           (v* (v- P10 P00) 9 (car ab*0))
                           (v* (v- P20 P10) 6 (car ab0)))
                       1/5))
               (Q2 (v* (v+ (v* Rbv0 3 (- (cdr ab*1) (cdr ab*0)))
                           (v* Rbv05 12 (cdr ab*0))
                           (v* Rbv1 (- (cdr ab0) (* 3 (cdr ab*0))))
                           (v* (v- P10 P00) 9 (car ab*1))
                           (v* (v- P20 P10) 18 (car ab*0))
                           (v* (v- P30 P20) 3 (car ab0)))
                       1/10))
               (Q3 (v* (v+ (v* Rbv0 (- (cdr ab1) (* 3 (cdr ab*1))))
                           (v* Rbv05 12 (cdr ab*1))
                           (v* Rbv1 3 (- (cdr ab*0) (cdr ab*1)))
                           (v* (v- P10 P00) 3 (car ab1))
                           (v* (v- P20 P10) 18 (car ab*1))
                           (v* (v- P30 P20) 9 (car ab*0)))
                       1/10))
               (Q4 (v* (v+ (v* Rbv0 -1 (cdr ab1))
                           (v* Rbv05 4 (cdr ab1))
                           (v* Rbv1 (- (* 3 (cdr ab*1)) (cdr ab1)))
                           (v* (v- P20 P10) 6 (car ab1))
                           (v* (v- P30 P20) 9 (car ab*1)))
                       1/5))
               (Q5 (v+ (v* Rbv1 (cdr ab1)) (v* (v- P30 P20) 3 (car ab1))))
               (quintic (elevate (elevate (car r1)))))
          (cons quintic
                (let ((scale/d (if cubic-cross-degree? 1/3 1/5)))
                  (map (lambda (p q) (v+ p (v* q scale/d)))
                       quintic (list Q0 Q1 Q2 Q3 Q4 Q5)))))))))

(define (direction-blend-quintic-tomi r1 r2)
  (bind-list (P00 P10 P20 P30) (car r1)
    (bind-list (P01 P11 P21 P31) (cdr r1)
      (bind-list (P0-1 P1-1 P2-1 P3-1) (cdr r2)
        (let* ((b0 (v* (v- P10 P00) 3))
               (b1 (v* (v- P20 P10) 3))
               (b2 (v* (v- P30 P20) 3))
               (a0 (v* (v- P01 P3-1) 3/2))
               (a1 (v* (v+ (v- P11 P2-1) (v- P21 P1-1)) 3/4 midvector-scale))
               (a2 (v* (v- P31 P0-1) 3/2))
               (q0 (v* (v- P01 P00) 3))
               (q1-cubic (v* (v- P11 P10) 3))
               (q1 (v+ (v* q0 2/5) (v* q1-cubic 3/5)))
               (q2-cubic (v* (v- P21 P20) 3))
               (q5 (v* (v- P31 P30) 3))
               (q4 (v+ (v* q5 2/5) (v* q2-cubic 3/5)))
               (ab0 (in-system q0 a0 b0))
               (ab3 (in-system q5 a2 b2))
               (ab1 (in-system (v+ (v* q1 5) (v* a1 -2 (car ab0)) (v* b1 -2 (cdr ab0)))
                               (v* a0 3) (v* b0 3)))
               (ab2 (in-system (v+ (v* q4 5) (v* a1 -2 (car ab3)) (v* b1 -2 (cdr ab3)))
                               (v* a2 3) (v* b2 3)))
               (c0 (v+ (v* a0 (car ab0)) (v* b0 (cdr ab0))))
               (c1 (v* (v+ (v* a0 3 (car ab1)) (v* a1 2 (car ab0))
                           (v* b0 3 (cdr ab1)) (v* b1 2 (cdr ab0)))
                       1/5))
               (c2 (v* (v+ (v* a0 3 (car ab2)) (v* a1 6 (car ab1)) (v* a2 (car ab0))
                           (v* b0 3 (cdr ab2)) (v* b1 6 (cdr ab1)) (v* b2 (cdr ab0)))
                       1/10))
               (c3 (v* (v+ (v* a0 (car ab3)) (v* a1 6 (car ab2)) (v* a2 3 (car ab1))
                           (v* b0 (cdr ab3)) (v* b1 6 (cdr ab2)) (v* b2 3 (cdr ab1)))
                       1/10))
               (c4 (v* (v+ (v* a1 2 (car ab3)) (v* a2 3 (car ab2))
                           (v* b1 2 (cdr ab3)) (v* b2 3 (cdr ab2)))
                       1/5))
               (c5 (v+ (v* a2 (car ab3)) (v* b2 (cdr ab3))))
               (quintic (elevate (elevate (car r1)))))
          (cons quintic
                (let ((scale/d (if cubic-cross-degree? 1/3 1/5)))
                  (map (lambda (p q) (v+ p (v* q scale/d)))
                       quintic (list c0 c1 c2 c3 c4 c5)))))))))

;;; Returns (face . side)
(define (opposite-side i j)
  (let* ((verts (vector-ref faces i))
         (n (length verts))
         (j+1 (modulo (+ j 1) n))
         (v0 (list-ref verts j))
         (v1 (list-ref verts j+1))
         (candidates (common-elements (vector-ref vertex-faces v0)
                                      (vector-ref vertex-faces v1)))
         (face (if (= (car candidates) i)
                   (cadr candidates)
                   (car candidates)))
         (side (find-index v1 (vector-ref faces face))))
    (cons face side)))

(define (fix-continuity ribbons)
  (let ((n (vector-length ribbons)))
    (do ((result (make-vector n))
         (i 0 (+ i 1)))
        ((= i n) result)
      (let ((face-ribbons (vector-ref ribbons i)))
        (vector-set! result i
                     (map (lambda (ribbon j)
                            (let* ((opp (opposite-side i j))
                                   (opp-face (vector-ref ribbons (car opp)))
                                   (opp-ribbon (list-ref opp-face (cdr opp))))
                              ((case direction-blend-type
                                 ((quartic-simple quartic-no-alpha) direction-blend-quartic)
                                 ((quartic-tomi-simple quartic-tomi-no-alpha)
                                  direction-blend-quartic-tomi)
                                 ((quintic) direction-blend-quintic)
                                 ((quintic-tomi) direction-blend-quintic-tomi)
                                 (else direction-blend ))
                               ribbon opp-ribbon)))
                          face-ribbons (range 0 (length face-ribbons))))))))

(define (update-ribbons)
  (set! ribbons
    (do ((result (make-vector (vector-length faces)))
         (i 0 (+ i 1)))
        ((= i (vector-length faces))
         (fix-continuity result))
      (vector-set! result i
                   (map (lambda (j)
                          (generate-ribbon i j))
                        (range 0 (length (vector-ref faces i))))))))


;;; Main function

(define (load-model filename)
  (let ((model (read-obj filename)))
    (set! vertices (car model))
    (set! faces (cdr model)))
  (update-topology)
  (update-offsets)
  (when shrink-chamfers?
    (for-each shrink-chamfer! (range 0 (vector-length vertices))))
  (update-ribbons))
