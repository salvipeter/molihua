;;; Global variables
(define vertices #f)
(define faces #f)
(define offset-vertices #f)
(define offset-faces #f)
(define vertex-faces #f)
(define ribbons #f)

(define midvector-weight 1)


;;; R7RS compatibility
(cond-expand
  (guile
   (use-modules (ice-9 rdelim))         ; read-line
   (define (vector-map f v)
     (let ((len (vector-length v)))
       (do ((result (make-vector len))
            (i 0 (+ i 1)))
           ((= i len) result)
         (vector-set! result i (f (vector-ref v i))))))
   (define (vector-for-each f v)
     (let ((len (vector-length v)))
       (do ((i 0 (+ i 1)))
           ((= i len))
         (f (vector-ref v i))))))
  (gambit))


;;; General utilities

(define (flatten-pairs lst)
  (cond ((null? lst)
         '())
        ((pair? (car lst))
         (cons (caar lst)
               (cons (cdar lst)
                     (flatten-pairs (cdr lst)))))
        (else
         (cons (car lst)
               (flatten-pairs (cdr lst))))))

;;; Brings the last element to the beginning
(define (rotate lst)
  (let loop ((lst lst) (acc '()))
    (if (null? (cdr lst))
        (append lst (reverse acc))
        (loop (cdr lst) (cons (car lst) acc)))))

;;; Split by spaces; multiple spaces count as one.
;;; Newlines are also count as spaces; starting/ending spaces are discounted.
;;; Trim chunks starting with '/' characters.
(define (split-string s)
  (define (stringify-car! lst)
    (set-car! lst (list->string (reverse (car lst)))))
  (do ((result (list (list)))
       (skip #f)
       (lst (string->list s) (cdr lst)))
      ((null? lst)
       (if (null? (car result))
           (set! result (cdr result))
           (stringify-car! result))
       (reverse result))
    (case (car lst)
      ((#\space #\return #\newline)
       (unless (null? (car result))
         (stringify-car! result)
         (set! result (cons (list) result))
         (set! skip #f)))
      ((#\/)
       (set! skip #t))
      (else (unless skip
              (set-car! result
                        (cons (car lst) (car result))))))))

;;; List of integers (from .. end-1)
(define (range from end)
  (let loop ((from from))
    (if (= from end)
        '()
        (cons from (loop (+ from 1))))))

(define (find-index elt lst)
  (let loop ((i 0) (lst lst))
    (cond ((null? lst) #f)
          ((eq? (car lst) elt) i)
          (else (loop (+ i 1) (cdr lst))))))

(define (common-element a b)
  (let loop ((a a))
    (cond ((null? a) #f)
          ((member (car a) b) (car a))
          (else (loop (cdr a))))))

(define (common-elements a b)
  (let loop ((a a))
    (cond ((null? a) '())
          ((member (car a) b)
           (cons (car a) (loop (cdr a))))
          (else (loop (cdr a))))))

(define (disjoint? a b)
  (eq? (common-element a b) #f))

;;; Finds a list in lst (a list of lists) that has
;;; common elements with both a and b (both lists).
(define (find-connection a b lst)
  (let loop ((lst lst))
    (cond ((null? lst) #f)
          ((or (disjoint? (car lst) a)
               (disjoint? (car lst) b))
           (loop (cdr lst)))
          (else (car lst)))))


;;; I/O routines

(define (read-obj filename)
  (with-input-from-file filename
    (lambda ()
      (do ((v '())
           (f '())
           (line (read-line) (read-line)))
          ((eof-object? line)
           (cons (list->vector (reverse v))
                 (list->vector (reverse f))))
        (let ((type (substring line 0 2)))
          (cond ((string-ci=? type "v ")
                 (let ((vertex (map string->number (cdr (split-string line)))))
                   (set! v (cons vertex v))))
                ((string-ci=? type "f ")
                 (let ((face (map (lambda (s)
                                    (- (string->number s) 1))
                                  (cdr (split-string line)))))
                   (set! f (cons face f))))))))))

(define (write-vertex v)
  (display "v")
  (for-each (lambda (xyz)
              (display " ")
              (display xyz))
            v)
  (newline))

(define (write-offsets filename)
  (with-output-to-file filename
    (lambda ()
      (vector-for-each write-vertex offset-vertices)
      (let ((write-face (lambda (face)
                          (display "f")
                          (for-each (lambda (v)
                                      (cond ((pair? v)
                                             (display " ")
                                             (display (+ (car v) 1))
                                             (display " ")
                                             (display (+ (cdr v) 1)))
                                            (else
                                             (display " ")
                                             (display (+ v 1)))))
                                    face)
                          (newline))))
        (if only-one-patch
            (write-face (vector-ref offset-faces only-one-patch))
            (vector-for-each write-face offset-faces))))))

(define (write-chamfers filename)
  (with-output-to-file filename
    (lambda ()
      (vector-for-each write-vertex offset-vertices)
      (let ((write-chamfer (lambda (i)
                             (display "f")
                             (for-each (lambda (v)
                                         (cond ((pair? v)
                                                (display " ")
                                                (display (+ (cdr v) 1))
                                                (display " ")
                                                (display (+ (car v) 1)))
                                               (else
                                                (display " ")
                                                (display (+ v 1)))))
                                       (chamfer i))
                             (newline))))
        (if only-one-patch
            (for-each write-chamfer (vector-ref faces only-one-patch))
            (do ((i 0 (+ i 1)))
                ((= i (vector-length vertices)))
              (write-chamfer i)))))))

;;; Show ribbon in Obj format;
;;; index is the number of already printed vertices.
;;; Returns the new index.
(define (show-ribbon ribbon index)
  (for-each write-vertex (append (car ribbon) (cdr ribbon)))
  (let ((line (lambda (indices)
                (display "l")
                (for-each (lambda (v)
                            (display " ")
                            (display (+ index v)))
                          indices)
                (newline))))
    (line '(1 2 3 4))
    (line '(5 6 7 8))
    (line '(1 5))
    (line '(2 6))
    (line '(3 7))
    (line '(4 8)))
  (+ index 8))

(define (write-controls filename)
  (with-output-to-file filename
    (lambda ()
      (do ((index 0)
           (i 0 (+ i 1)))
          ((= i (vector-length faces)))
        (when (or (not only-one-patch)
                  (= only-one-patch i))
          (for-each (lambda (ribbon)
                      (set! index (show-ribbon ribbon index)))
                    (vector-ref ribbons i)))))))

(define (write-patches-mp filename-prefix)
  (do ((index 0)
       (i 0 (+ i 1)))
      ((= i (vector-length faces)))
    (when (or (not only-one-patch)
              (= only-one-patch i))
      (with-output-to-file
          (string-append filename-prefix (number->string (+ i 1)) ".mp")
        (lambda ()
          (let ((n (length (vector-ref faces i)))
                (write-curve (lambda (cpts)
                               (display "3 4")
                               (newline)
                               (display "0 0 0 0 1 1 1 1")
                               (newline)
                               (for-each (lambda (vertex)
                                           (for-each (lambda (xyz)
                                                       (display xyz)
                                                       (display " "))
                                                     vertex)
                                           (newline))
                                         cpts))))
            (display n)
            (newline)
            (for-each (lambda (ribbon)
                        (write-curve (car ribbon))
                        (write-curve (cdr ribbon)))
                      (vector-ref ribbons i))))))))

(define (write-patches-cgb filename-prefix)
  (do ((index 0)
       (i 0 (+ i 1)))
      ((= i (vector-length faces)))
    (when (or (not only-one-patch)
              (= only-one-patch i))
      (with-output-to-file
          (string-append filename-prefix (number->string (+ i 1)) ".cgb")
        (lambda ()
          (let ((n (length (vector-ref faces i))))
            (display 0) (newline)
            (display 3) (newline)
            (display 0) (newline)
            (display 0) (newline)
            (display n) (newline)
            (display "0 0 0") (newline)
            (for-each (lambda (ribbon)
                        (display "3 2") (newline)
                        (for-each (lambda (p)
                                    (display (car p)) (display " ")
                                    (display (cadr p)) (display " ")
                                    (display (caddr p)) (newline))
                                  (append (car ribbon) (cdr ribbon))))
                      (vector-ref ribbons i))
            (display 0) (newline)
            (do ((j 0 (+ j 1)))
                ((= j n) (newline))
              (display 1) (display " "))))))))

(define (write-patches-mgbs filename-prefix)
  (do ((index 0)
       (i 0 (+ i 1)))
      ((= i (vector-length faces)))
    (when (or (not only-one-patch)
              (= only-one-patch i))
      (with-output-to-file
          (string-append filename-prefix (number->string (+ i 1)) ".mgbs")
        (lambda ()
          (let ((n (length (vector-ref faces i))))
            (display 1) (newline)       ; # of loops
            (display n) (newline)       ; # of sides
            (for-each (lambda (ribbon)
                        (display "3 3 2 0") (newline) ; s-deg h-deg layers ribcp?
                        (display "0 0 0 0 1 1 1 1") (newline) ; s-knots
                        (for-each (lambda (p)
                                    (display (car p)) (display " ")
                                    (display (cadr p)) (display " ")
                                    (display (caddr p)) (newline))
                                  (append (car ribbon) (cdr ribbon))))
                      (vector-ref ribbons i))
            (display "400 200") (newline))))))) ; curve-res triangle-res

(define (write-qds ribbons filename)
  (with-output-to-file filename
    (lambda ()
      (display (length ribbons))
      (newline)
      (for-each (lambda (ribbon)
                  (display "1 3") (newline)
                  (display "4 0 0 1 1") (newline)
                  (display "8 0 0 0 0 1 1 1 1") (newline)
                  (for-each (lambda (p)
                              (display (car p)) (display " ")
                              (display (cadr p)) (display " ")
                              (display (caddr p)) (newline))
                            (append (car ribbon) (cdr ribbon))))
                ribbons))))


;;; Geometry procedures

(define (v+ . args)
  (apply map + args))

(define (v- . args)
  (apply map - args))

(define (v* u . args)
  (map (lambda (x) (apply * x args)) u))

(define (scalar-product u v)
  (apply + (map * u v)))

(define (cross-product u v)
  (list (- (* (cadr u) (caddr v)) (* (caddr u) (cadr v)))
	(- (* (caddr u) (car v)) (* (car u) (caddr v)))
	(- (* (car u) (cadr v)) (* (cadr u) (car v)))))

(define (vlength u)
  (sqrt (scalar-product u u)))

(define (vnormalize u)
  (v* u (/ (vlength u))))

;;; Returns (a . b) such that u = v a + w b.
(define (in-system u v w)
  (let ((v2 (scalar-product v v))
        (w2 (scalar-product w w))
        (uv (scalar-product u v))
        (uw (scalar-product u w))
        (vw (scalar-product v w)))
    (let ((denom (- (* v2 w2) (* vw vw))))
      (cons (/ (- (* w2 uv) (* vw uw)) denom)
            (/ (- (* v2 uw) (* vw uv)) denom)))))

(define (point-distance p q)
  (vlength (v- q p)))

;;; Line is given as (point . point)
(define (line-point-distance line p)
  (let* ((q1 (car line))
         (q2 (cdr line))
         (v (v- p q1))
         (d (v- q2 q1)))
    (vlength (v- v (v* d (/ (scalar-product v d)
                            (scalar-product d d)))))))

;;; Pushes the line towards the point by `offset` part of their distance
(define (push-line line point offset)
  (let ((d (v* (v- point (car line)) offset)))
    (cons (v+ (car line) d)
          (v+ (cdr line) d))))

(define (line-line-intersection l1 l2)
  (let* ((ap (car l1))
         (ad (v- (cdr l1) (car l1)))
         (bp (car l2))
         (bd (v- (cdr l2) (car l2)))
         (a (scalar-product ad ad))
         (b (scalar-product ad bd))
         (c (scalar-product bd bd))
         (d (scalar-product ad (v- ap bp)))
         (e (scalar-product bd (v- ap bp))))
    (let ((denom (- (* a c) (* b b))))
      (if (< denom 1e-7)
          (error "parallel lines")
          (let ((s (/ (- (* b e) (* c d)) denom))
                (t (/ (- (* a e) (* b d)) denom)))
            (v* (v+ ap (v* ad s) bp (v* bd t)) 0.5))))))

(define (intersecting-segments? l1 l2)
  (let* ((ap (car l1))
         (ad (v- (cdr l1) (car l1)))
         (bp (car l2))
         (bd (v- (cdr l2) (car l2)))
         (a (scalar-product ad ad))
         (b (scalar-product ad bd))
         (c (scalar-product bd bd))
         (d (scalar-product ad (v- ap bp)))
         (e (scalar-product bd (v- ap bp))))
    (let ((denom (- (* a c) (* b b))))
      (if (< denom 1e-7)
          (and (< (vlength (cross-product bd (v- ap bp))) 1e-4) ; on the same line
               (not (or (< (scalar-product (v- (cdr l1) bp) ad) 0)
                        (< (scalar-product (v- (cdr l2) ap) ad) 0))))
          (let ((s (/ (- (* b e) (* c d)) denom))
                (t (/ (- (* a e) (* b d)) denom)))
            (and (<= 0 s 1) (<= 0 t 1)
                 (< (point-distance (v+ ap (v* ad s))
                                    (v+ bp (v* bd t)))
                    1e-5)))))))

(define (closest-vertex line verts)
  (let loop ((best #f) (dist #f) (lst verts))
    (cond ((null? lst) best)
          ((or (equal? (car line) (car lst))
               (equal? (cdr line) (car lst)))
           (loop best dist (cdr lst)))
          (else (let ((d (line-point-distance line (car lst))))
                  (if (or (not dist) (< d dist))
                      (loop (car lst) d (cdr lst))
                      (loop best dist (cdr lst))))))))

(define (out-normal line1 line2)
  (let* ((d1 (v- (cdr line1) (car line1)))
         (d2 (v- (cdr line2) (car line2))))
    (vnormalize (cross-product d1 d2))))

(define (concave-corner? line1 line2 normal)
  (< (scalar-product normal (out-normal line1 line2)) 0))

;;; A vertex is reachable if:
;;; - it is not one of the endpoints of `line`
;;; - the triangle defined by `line` and the vertex (i.e., l1 l2 p)
;;;   has correct orientation (w.r.t. `normal`)
;;; - the segments (l1 p) and (l2 p) do not intersect other segments
;;;   (but can be exactly one of `lines`)
(define (reachable-vertices line verts lines normal)
  (define (intersecting? segment)
    (let loop ((lst lines))
      (cond ((null? lst) #f)
            ((or (equal? (car segment) (caar lst))
                 (equal? (car segment) (cdar lst))
                 (equal? (cdr segment) (caar lst))
                 (equal? (cdr segment) (cdar lst)))
             (loop (cdr lst)))
            ((intersecting-segments? segment (car lst)) #t)
            (else (loop (cdr lst))))))
  (filter (lambda (v)
            (not (or (equal? v (car line))
                     (equal? v (cdr line))
                     (concave-corner? line (cons (cdr line) v) normal)
                     (intersecting? (cons v (car line)))
                     (intersecting? (cons (cdr line) v)))))
          verts))

;;; Assumes that the first corner is not concave
(define (offset-face verts)
  (let* ((lines (map cons verts (append (cdr verts) (list (car verts)))))
         (n (face-normal verts))
         (points (map (lambda (l)
                        (closest-vertex l (reachable-vertices l verts lines n)))
                      lines))
         (offsets (map (lambda (l p) (push-line l p (/ fullness 2))) lines points)))
    (let loop ((l1 (rotate lines)) (l2 lines)
               (o1 (rotate offsets)) (o2 offsets))
      (cond ((null? l1)
             '())
            ((concave-corner? (car l1) (car l2) n)
             (cons (list 'concave
                         (line-line-intersection (car o1) (car l2))
                         (line-line-intersection (car o2) (car l1)))
                   (loop (cdr l1) (cdr l2) (cdr o1) (cdr o2))))
            (else
             (cons (line-line-intersection (car o1) (car o2))
                   (loop (cdr l1) (cdr l2) (cdr o1) (cdr o2))))))))

;;; Returns (verts* . faces*)
(define (generate-offsets vertices faces)
  (do ((rfaces (make-vector (vector-length faces)))
       (rvertices '())
       (index 0)
       (i 0 (+ i 1)))
      ((= i (vector-length faces))
       (cons (list->vector (reverse rvertices)) rfaces))
    (let* ((off (offset-face
                 (map (lambda (v)
                        (vector-ref vertices v))
                      (vector-ref faces i))))
           (flat (apply append (map (lambda (x)
                                      (if (eq? (car x) 'concave)
                                          (cdr x)
                                          (list x)))
                                    off)))
           (n (length flat)))
      (set! rvertices (append (reverse flat) rvertices))
      (vector-set! rfaces i
                   (let loop ((lst off) (i index))
                     (cond ((null? lst)
                            '())
                           ((eq? (caar lst) 'concave)
                            (cons (cons i (+ i 1))
                                  (loop (cdr lst) (+ i 2))))
                           (else
                            (cons i (loop (cdr lst) (+ i 1)))))))
      (set! index (+ index n)))))

(define (update-topology)
  (set! vertex-faces
    (do ((result (make-vector (vector-length vertices) '()))
         (i 0 (+ i 1)))
        ((= i (vector-length faces))
         (vector-map fix-order result))
      (for-each (lambda (v)
                  (vector-set! result v
                               (cons i (vector-ref result v))))
                (vector-ref faces i)))))

(define (update-offsets)
  (let ((offsets (generate-offsets vertices faces)))
    (set! offset-vertices (car offsets))
    (set! offset-faces (cdr offsets))))

;;; Moves the adjacent face to the beginning
(define (select-adjacent face lst)
  (let loop ((lst lst) (acc '()))
    (cond ((null? lst)
           (error "cannot find adjacent face"))
          ((= (length (common-elements (vector-ref faces face)
                                       (vector-ref faces (car lst))))
              2)
           (cons (car lst) (append acc (cdr lst))))
          (else
           (loop (cdr lst) (cons (car lst) acc))))))

;;; Permute the list of faces to be cyclic
(define (fix-order faces)
  (let loop ((lst faces))
    (if (null? (cdr lst))
        lst
        (cons (car lst)
              (loop (select-adjacent (car lst) (cdr lst)))))))

;;; Sum the cross products of each edge endpoints & normalize
(define (face-normal points)
  (let ((edges (map cons points (append (cdr points) (list (car points))))))
    (vnormalize
     (let loop ((lst edges))
       (if (null? lst)
           '(0 0 0)
           (v+ (cross-product (caar lst) (cdar lst))
               (loop (cdr lst))))))))

;;; Returns the chamfer associated with the v-th vertex.
;;; The result is a list of indices to offset-vertices.
(define (chamfer v)
  (let* ((face-indices (vector-ref vertex-faces v))
         (lst (map (lambda (f)
                     (list-ref (vector-ref offset-faces f)
                               (find-index v (vector-ref faces f))))
                   face-indices))
         (face (map (lambda (v) (vector-ref vertices v))
                    (vector-ref faces (car face-indices))))
         (chamfer-face (map (lambda (v)
                              (if (pair? v)
                                  (v* (v+ (vector-ref offset-vertices (car v))
                                          (vector-ref offset-vertices (cdr v)))
                                      1/2)
                                  (vector-ref offset-vertices v)))
                            lst)))
    (if (< (scalar-product (face-normal face)
                           (face-normal chamfer-face))
           0)
        (reverse lst)
        lst)))

;;; At vertex j with chamfer c0, find the face connecting to chamfer c1,
;;; which is the opposite of face i (i.e., not face i).
(define (find-opposite i j c0 c1)
  (let ((candidates
         (let loop ((lst (vector-ref vertex-faces j)))
           (cond ((null? lst) '())
                 ((= (car lst) i) (loop (cdr lst)))
                 (else (cons (vector-ref offset-faces (car lst))
                             (loop (cdr lst))))))))
    (find-connection c0 c1 candidates)))

;;; Face i side j
;;; m: chamfer midpoint
;;; o: chamfer vertex in the current face
;;; e: chamfer midpoint between the current and opposite faces
;;; f: chamfer midpoint between the current and adjacent-opposite faces
(define (generate-ribbon i j)
  (let* ((face (vector-ref faces i))
         (offset-face (vector-ref offset-faces i))
         (n (length face))
         (j-1 (modulo (- j 1) n))
         (j+1 (modulo (+ j 1) n))
         (j+2 (modulo (+ j 2) n))
         (c0 (chamfer (list-ref face j)))
         (c1 (chamfer (list-ref face j+1)))
         (fc0 (flatten-pairs c0))
         (fc1 (flatten-pairs c1))
         (m0 (v* (apply v+ (map (lambda (v)
                                  (vector-ref offset-vertices v))
                                fc0))
                 (/ (length fc0))))
         (m1 (v* (apply v+ (map (lambda (v)
                                  (vector-ref offset-vertices v))
                                fc1))
                 (/ (length fc1))))
         (select-from-pair (lambda (f x) (if (pair? x) (f x) x)))
         (scaled-offset (lambda (c f i)
                          (let ((i (select-from-pair f i)))
                            (v+ c (v* (v- (vector-ref offset-vertices i) c)
                                            tangent-scale)))))
         (o0 (scaled-offset m0 cdr (list-ref offset-face j)))
         (o1 (scaled-offset m1 car (list-ref offset-face j+1)))
         ;; the opposite face includes a vertex index from both c0 and c1
         (opp (find-opposite i (list-ref face j) c0 c1))
         (opp-1 (find-opposite i (list-ref face j) c0 (chamfer (list-ref face j-1))))
         (opp+1 (find-opposite i (list-ref face j+1) c1 (chamfer (list-ref face j+2))))
         (e0 (v* (v+ o0 (scaled-offset m0 car (common-element c0 opp))) 1/2))
         (e1 (v* (v+ o1 (scaled-offset m1 cdr (common-element c1 opp))) 1/2))
         (f0 (v* (v+ o0 (if (pair? (list-ref offset-face j))
                            (scaled-offset m0 car (list-ref offset-face j))
                            (scaled-offset m0 cdr (common-element c0 opp-1))))
                 1/2))
         (f1 (v* (v+ o1 (if (pair? (list-ref offset-face j+1))
                            (scaled-offset m1 cdr (list-ref offset-face j+1))
                            (scaled-offset m1 car (common-element c1 opp+1))))
                 1/2)))
    (cons (list m0 e0 e1 m1)
          (list f0 o0 o1 f1))))

;;; Computes a variation of r1 matching the mean cross-derivative with r2
(define (direction-blend r1 r2)
  (let* ((P0 (list-ref (car r1) 0))
         (P1 (list-ref (car r1) 1))
         (P2 (list-ref (car r1) 2))
         (P3 (list-ref (car r1) 3))
         (Ru0 (v* (v- P1 P0) 3))
         (Rv0 (v- (list-ref (cdr r1) 0) P0))
         (Sv0 (v- (list-ref (cdr r2) 3) P0))
         (Ru1 (v* (v- P3 P2) 3))
         (Rv1 (v- (list-ref (cdr r1) 3) P3))
         (Sv1 (v- (list-ref (cdr r2) 0) P3))
         (Rv05 (v* (v+ Rv0 (v* (v- (list-ref (cdr r1) 1) P1) 3)
                       Rv1 (v* (v- (list-ref (cdr r1) 2) P2) 3))
                   1/8))
         (Sv05 (v* (v+ Sv0 (v* (v- (list-ref (cdr r2) 2) P1) 3)
                       Sv1 (v* (v- (list-ref (cdr r2) 1) P2) 3))
                   1/8))
         (Mv0 (v* (v- Rv0 Sv0) 1/2))
         (Mv05 (v* (v- Rv05 Sv05) 1/2 midvector-weight))
         (Mv1 (v* (v- Rv1 Sv1) 1/2))
         (ab0 (in-system Rv0 Mv0 Ru0))
         (ab1 (in-system Rv1 Mv1 Ru1))
         (a0 (car ab0))
         (a1 (car ab1))
         (b0 (cdr ab0))
         (b1 (cdr ab1))
         (Q0 (v+ (v* Mv0 a0) (v* Ru0 b0)))
         (Q1 (v+ (v* Mv0 1/3 (- a1 a0)) (v* Mv05 4/3 a0) (v* Mv1 -1/3 a0)
                 (v* Ru0 1/3 b1) (v* (v- P2 P1) 2 b0)))
         (Q2 (v+ (v* Mv0 -1/3 a1) (v* Mv05 4/3 a1) (v* Mv1 1/3 (- a0 a1))
                 (v* (v- P2 P1) 2 b1) (v* Ru1 1/3 b0)))
         (Q3 (v+ (v* Mv1 a1) (v* Ru1 b1))))
    (cons (car r1)
          (map (lambda (p q) (v+ p q))
               (list P0 P1 P2 P3) (list Q0 Q1 Q2 Q3)))))

;;; Returns (face . side)
(define (opposite-side i j)
  (let* ((verts (vector-ref faces i))
         (n (length verts))
         (j+1 (modulo (+ j 1) n))
         (v0 (list-ref verts j))
         (v1 (list-ref verts j+1))
         (candidates (common-elements (vector-ref vertex-faces v0)
                                      (vector-ref vertex-faces v1)))
         (face (if (= (car candidates) i)
                   (cadr candidates)
                   (car candidates)))
         (side (find-index v1 (vector-ref faces face))))
    (cons face side)))

(define (fix-continuity ribbons)
  (let ((n (vector-length ribbons)))
    (do ((result (make-vector n))
         (i 0 (+ i 1)))
        ((= i n) result)
      (let ((face-ribbons (vector-ref ribbons i)))
        (vector-set! result i
                     (map (lambda (ribbon j)
                            (let* ((opp (opposite-side i j))
                                   (opp-face (vector-ref ribbons (car opp)))
                                   (opp-ribbon (list-ref opp-face (cdr opp))))
                              (direction-blend ribbon opp-ribbon)))
                          face-ribbons (range 0 (length face-ribbons))))))))

(define (update-ribbons)
  (set! ribbons
    (do ((result (make-vector (vector-length faces)))
         (i 0 (+ i 1)))
        ((= i (vector-length faces))
         (fix-continuity result))
      (vector-set! result i
                   (map (lambda (j)
                          (generate-ribbon i j))
                        (range 0 (length (vector-ref faces i))))))))


;;; Main function

(define (load-model filename)
  (let ((model (read-obj filename)))
    (set! vertices (car model))
    (set! faces (cdr model)))
  (update-topology)
  (update-offsets)
  (update-ribbons))
