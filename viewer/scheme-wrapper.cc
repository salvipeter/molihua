#include "scheme-wrapper.hh"

#include <iostream>

#ifndef USE_CHIBI_SCHEME

namespace SchemeWrapper {

  void initialize() {
    scm_init_guile();
    scm_set_current_warning_port(scm_open_output_string()); // quiet
    evaluateString("(set! %load-should-auto-compile #f)");
    evaluateString("(import (scheme base))");
  }

  void setVariable(std::string var, Sexp val) {
    scm_c_define(var.c_str(), val);
  }

  Sexp getVariable(std::string var) {
    return scm_variable_ref(scm_c_lookup(var.c_str()));
  }

  bool isNull(Sexp sexp) {
    return scm_null_p(sexp) == SCM_BOOL_T;
  }

  bool isPair(Sexp sexp) {
    return scm_is_pair(sexp);
  }

  bool isFalse(Sexp sexp) {
    return sexp == SCM_BOOL_F;
  }

  unsigned int sexp2uint(Sexp sexp) {
    return scm_to_uint(sexp);
  }

  double sexp2double(Sexp sexp) {
    return scm_to_double(sexp);
  }

  Sexp bool2sexp(bool b) {
    return b ? SCM_BOOL_T : SCM_BOOL_F;
  }

  Sexp uint2sexp(unsigned int n) {
    return scm_from_uint(n);
  }

  Sexp double2sexp(double x) {
    return scm_from_double(x);
  }

  Sexp string2symbol(std::string s) {
    return scm_from_utf8_symbol(s.c_str());
  }

  Sexp car(Sexp cons) {
    return scm_car(cons);
  }

  Sexp cdr(Sexp cons) {
    return scm_cdr(cons);
  }

  unsigned int listLength(Sexp lst) {
    return scm_to_uint(scm_length(lst));
  }

  Sexp listElement(Sexp lst, unsigned int i) {
    return scm_list_ref(lst, scm_from_uint(i));
  }

  unsigned int vectorLength(Sexp vec) {
    return scm_to_uint(scm_vector_length(vec));
  }

  Sexp vectorElement(Sexp vec, unsigned int i) {
    return scm_vector_ref(vec, scm_from_uint(i));
  }

  Sexp evaluateString(std::string s) {
    return scm_c_eval_string(s.c_str());
  }

}

#else // USE_CHIBI_SCHEME

namespace SchemeWrapper {       // Generated by Gemini

  // Global context required by Chibi for all operations
  static sexp global_ctx = nullptr;
  static sexp global_env = nullptr;

  void initialize() {
    // 1. Initialize the library
    sexp_scheme_init();

    // 2. Create the evaluation context
    // args: (allocator, heap_size, max_indent, initial_stack_size, flags)
    global_ctx = sexp_make_eval_context(NULL, NULL, NULL, 0, 0);

    // 3. Load the standard environment (R7RS)
    global_env = sexp_load_standard_env(global_ctx, NULL, SEXP_SEVEN);
    
    // 4. Load standard ports (stdin/stdout) so 'display' works
    sexp_load_standard_ports(global_ctx, NULL, stdin, stdout, stderr, 0);

    evaluateString("(import (scheme base) (scheme cxr))");
  }

  // --- Variable Management ---

  void setVariable(std::string var, Sexp val) {
    // Intern creates the symbol from the string
    sexp sym = sexp_intern(global_ctx, var.c_str(), -1);
    
    // Define the variable in the global environment
    sexp_env_define(global_ctx, global_env, sym, val);
  }

  Sexp getVariable(std::string var) {
    sexp sym = sexp_intern(global_ctx, var.c_str(), -1);
    
    // Search the environment for the symbol
    // SEXP_FALSE is returned if not found (or if value is false)
    return sexp_env_ref(global_ctx, global_env, sym, SEXP_FALSE);
  }

  // --- Type Predicates ---

  bool isNull(Sexp s) {
    return sexp_nullp(s);
  }

  bool isPair(Sexp s) {
    return sexp_pairp(s);
  }

  bool isFalse(Sexp s) {
    return sexp_not(s);
  }

  // --- Scheme -> C++ Conversion ---

  unsigned int sexp2uint(Sexp s) {
    return (unsigned int)sexp_uint_value(s);
  }

  double sexp2double(Sexp s) {
    if (sexp_flonump(s))
      return sexp_flonum_value(s);
    return (double)sexp_sint_value(s);
  }

  // --- C++ -> Scheme Conversion ---

  Sexp bool2sexp(bool b) {
    return sexp_make_boolean(b);
  }

  Sexp uint2sexp(unsigned int n) {
    // sexp_make_integer handles Fixnums vs Bignums automatically
    return sexp_make_integer(global_ctx, n);
  }

  Sexp double2sexp(double x) {
    return sexp_make_flonum(global_ctx, x);
  }

  Sexp string2symbol(std::string s) {
    // -1 length tells Chibi to use strlen()
    return sexp_intern(global_ctx, s.c_str(), -1);
  }

  // --- List Operations ---

  Sexp car(Sexp cons) {
    return sexp_car(cons);
  }

  Sexp cdr(Sexp cons) {
    return sexp_cdr(cons);
  }

  unsigned int listLength(Sexp lst) {
    // sexp_length returns a sexp (integer), so we unbox it
    return (unsigned int)sexp_unbox_fixnum(sexp_length(global_ctx, lst));
  }

  Sexp listElement(Sexp lst, unsigned int i) {
    // Chibi doesn't have a direct O(n) C-api list_ref, 
    // we use the generic list iterator provided by Chibi macros or manual loop.
    // However, sexp_list_ref does exist in some versions, but to be safe:
    Sexp curr = lst;
    while (i > 0 && sexp_pairp(curr)) {
        curr = sexp_cdr(curr);
        i--;
    }
    if (sexp_pairp(curr)) return sexp_car(curr);
    return SEXP_FALSE;
  }

  // --- Vector Operations ---

  unsigned int vectorLength(Sexp vec) {
    return (unsigned int)sexp_vector_length(vec);
  }

  Sexp vectorElement(Sexp vec, unsigned int i) {
    // Direct access to vector data array
    return sexp_vector_data(vec)[i];
  }

  // --- Evaluation ---

  Sexp evaluateString(std::string s) {
    // sexp_eval_string arguments: context, string, length (-1=auto), environment
    return sexp_eval_string(global_ctx, s.c_str(), -1, NULL);
  }

}

#endif
