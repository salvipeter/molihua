#include "scheme-wrapper.hh"

#include <iostream>

#ifdef USE_GUILE_SCHEME

namespace SchemeWrapper {

  void initialize() {
    scm_init_guile();
    scm_set_current_warning_port(scm_open_output_string()); // quiet
    evaluateString("(set! %load-should-auto-compile #f)");
    evaluateString("(import (scheme base))");
  }

  void setVariable(std::string var, Sexp val) {
    scm_c_define(var.c_str(), val);
  }

  Sexp getVariable(std::string var) {
    return scm_variable_ref(scm_c_lookup(var.c_str()));
  }

  bool isNull(Sexp sexp) {
    return scm_null_p(sexp) == SCM_BOOL_T;
  }

  bool isPair(Sexp sexp) {
    return scm_is_pair(sexp);
  }

  bool isFalse(Sexp sexp) {
    return sexp == SCM_BOOL_F;
  }

  unsigned int sexp2uint(Sexp sexp) {
    return scm_to_uint(sexp);
  }

  double sexp2double(Sexp sexp) {
    return scm_to_double(sexp);
  }

  Sexp bool2sexp(bool b) {
    return b ? SCM_BOOL_T : SCM_BOOL_F;
  }

  Sexp uint2sexp(unsigned int n) {
    return scm_from_uint(n);
  }

  Sexp double2sexp(double x) {
    return scm_from_double(x);
  }

  Sexp string2symbol(std::string s) {
    return scm_from_utf8_symbol(s.c_str());
  }

  Sexp car(Sexp cons) {
    return scm_car(cons);
  }

  Sexp cdr(Sexp cons) {
    return scm_cdr(cons);
  }

  unsigned int listLength(Sexp lst) {
    return scm_to_uint(scm_length(lst));
  }

  Sexp listElement(Sexp lst, unsigned int i) {
    return scm_list_ref(lst, scm_from_uint(i));
  }

  unsigned int vectorLength(Sexp vec) {
    return scm_to_uint(scm_vector_length(vec));
  }

  Sexp vectorElement(Sexp vec, unsigned int i) {
    return scm_vector_ref(vec, scm_from_uint(i));
  }

  Sexp evaluateString(std::string s) {
    return scm_c_eval_string(s.c_str());
  }

}

#elif defined(USE_S7_SCHEME)

namespace SchemeWrapper {       // Generated by Gemini

  // Global pointer to the s7 interpreter instance
  static s7_scheme* sc = nullptr;

  void initialize() {
    sc = s7_init();

    s7_add_to_load_path(sc, "s7");
    s7_add_to_load_path(sc, ".");
    s7_load(sc, "r7rs.scm");

    // 'bytevector?' is an R7RS function not in core s7
    s7_pointer check = s7_name_to_value(sc, "bytevector?");
    if (check == s7_undefined(sc))
      std::cerr << "R7RS environment NOT loaded correctly." << std::endl;
  }

  void setVariable(std::string var, Sexp val) {
    // s7_define maps a symbol to a value in the global environment
    s7_define(sc, s7_nil(sc), s7_make_symbol(sc, var.c_str()), val);
  }

  Sexp getVariable(std::string var) {
    // s7_name_to_value looks up a symbol in the current environment
    return s7_name_to_value(sc, var.c_str());
  }

  // --- Type Predicates ---

  bool isNull(Sexp s) {
    return s == s7_nil(sc);
  }

  bool isPair(Sexp s) {
    return s7_is_pair(s);
  }

  bool isFalse(Sexp s) {
    return s == s7_f(sc);
  }

  // --- Scheme -> C++ Conversion ---

  unsigned int sexp2uint(Sexp s) {
    return (unsigned int)s7_integer(s);
  }

  double sexp2double(Sexp s) {
    return s7_number_to_real(sc, s);
  }

  // --- C++ -> Scheme Conversion ---

  Sexp bool2sexp(bool b) {
    return b ? s7_t(sc) : s7_f(sc);
  }

  Sexp uint2sexp(unsigned int n) {
    return s7_make_integer(sc, (int)n);
  }

  Sexp double2sexp(double x) {
    return s7_make_real(sc, x);
  }

  Sexp string2symbol(std::string s) {
    return s7_make_symbol(sc, s.c_str());
  }

  // --- List Operations ---

  Sexp car(Sexp cons) {
    return s7_car(cons);
  }

  Sexp cdr(Sexp cons) {
    return s7_cdr(cons);
  }

  unsigned int listLength(Sexp lst) {
    return (unsigned int)s7_list_length(sc, lst);
  }

  Sexp listElement(Sexp lst, unsigned int i) {
    return s7_list_ref(sc, lst, (int)i);
  }

  // --- Vector Operations ---

  unsigned int vectorLength(Sexp vec) {
    return (unsigned int)s7_vector_length(vec);
  }

  Sexp vectorElement(Sexp vec, unsigned int i) {
    return s7_vector_ref(sc, vec, (int)i);
  }

  // --- Evaluation ---

  Sexp evaluateString(std::string s) {
    return s7_eval_c_string(sc, s.c_str());
  }

}

#else // USE_CHIBI_SCHEME

namespace SchemeWrapper {       // Generated by Gemini

  // Global context required by Chibi for all operations
  static sexp global_ctx = nullptr;
  static sexp global_env = nullptr;

  void initialize() {
    // 1. Initialize the library
    sexp_scheme_init();

    // 2. Create the evaluation context
    // args: (allocator, heap_size, max_indent, initial_stack_size, flags)
    global_ctx = sexp_make_eval_context(NULL, NULL, NULL, 0, 0);

    // 3. Load the standard environment (R7RS)
    global_env = sexp_load_standard_env(global_ctx, NULL, SEXP_SEVEN);
    
    // 4. Load standard ports (stdin/stdout) so 'display' works
    sexp_load_standard_ports(global_ctx, NULL, stdin, stdout, stderr, 0);

    evaluateString("(import (scheme base) (scheme cxr))");
  }

  // --- Variable Management ---

  void setVariable(std::string var, Sexp val) {
    // Intern creates the symbol from the string
    sexp sym = sexp_intern(global_ctx, var.c_str(), -1);
    
    // Define the variable in the global environment
    sexp_env_define(global_ctx, global_env, sym, val);
  }

  Sexp getVariable(std::string var) {
    sexp sym = sexp_intern(global_ctx, var.c_str(), -1);
    
    // Search the environment for the symbol
    // SEXP_FALSE is returned if not found (or if value is false)
    return sexp_env_ref(global_ctx, global_env, sym, SEXP_FALSE);
  }

  // --- Type Predicates ---

  bool isNull(Sexp s) {
    return sexp_nullp(s);
  }

  bool isPair(Sexp s) {
    return sexp_pairp(s);
  }

  bool isFalse(Sexp s) {
    return sexp_not(s);
  }

  // --- Scheme -> C++ Conversion ---

  unsigned int sexp2uint(Sexp s) {
    return (unsigned int)sexp_uint_value(s);
  }

  double sexp2double(Sexp s) {
    if (sexp_flonump(s))
      return sexp_flonum_value(s);
    return (double)sexp_sint_value(s);
  }

  // --- C++ -> Scheme Conversion ---

  Sexp bool2sexp(bool b) {
    return sexp_make_boolean(b);
  }

  Sexp uint2sexp(unsigned int n) {
    // sexp_make_integer handles Fixnums vs Bignums automatically
    return sexp_make_integer(global_ctx, n);
  }

  Sexp double2sexp(double x) {
    return sexp_make_flonum(global_ctx, x);
  }

  Sexp string2symbol(std::string s) {
    // -1 length tells Chibi to use strlen()
    return sexp_intern(global_ctx, s.c_str(), -1);
  }

  // --- List Operations ---

  Sexp car(Sexp cons) {
    return sexp_car(cons);
  }

  Sexp cdr(Sexp cons) {
    return sexp_cdr(cons);
  }

  unsigned int listLength(Sexp lst) {
    // sexp_length returns a sexp (integer), so we unbox it
    return (unsigned int)sexp_unbox_fixnum(sexp_length(global_ctx, lst));
  }

  Sexp listElement(Sexp lst, unsigned int i) {
    // Chibi doesn't have a direct O(n) C-api list_ref, 
    // we use the generic list iterator provided by Chibi macros or manual loop.
    // However, sexp_list_ref does exist in some versions, but to be safe:
    Sexp curr = lst;
    while (i > 0 && sexp_pairp(curr)) {
        curr = sexp_cdr(curr);
        i--;
    }
    if (sexp_pairp(curr)) return sexp_car(curr);
    return SEXP_FALSE;
  }

  // --- Vector Operations ---

  unsigned int vectorLength(Sexp vec) {
    return (unsigned int)sexp_vector_length(vec);
  }

  Sexp vectorElement(Sexp vec, unsigned int i) {
    // Direct access to vector data array
    return sexp_vector_data(vec)[i];
  }

  // --- Evaluation ---

  Sexp evaluateString(std::string s) {
    // sexp_eval_string arguments: context, string, length (-1=auto), environment
    return sexp_eval_string(global_ctx, s.c_str(), -1, NULL);
  }

}

#endif
